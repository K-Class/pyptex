\documentclass{article}

% This doesn't actually work.
\pdfinfoomitdate1
\pdfsuppressptexinfo-1
\pdftrailerid{}

\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{amsmath}
\usepackage{verbatim}
\usepackage{relsize}
\usepackage{graphicx}

\usepackage{hologo}



\newcommand{\Longupdownarrow}{\Big\Updownarrow}
\usepackage{listings}
\lstset{
   basicstyle=\footnotesize\ttfamily}

\usepackage{natbib}

\newcommand{\pyptex}{{P\kern-0.08em\raisebox{-0.5ex}{Y\kern-0.1emP}\kern-0.28em\TeX{}}}

\title{\pyptex{}: The Python Preprocessor for \LaTeX{}.}
\date{wololo}
\author{SÃ©bastien Loisel}


\begin{document}
\maketitle

\begin{abstract}
\pyptex{} is a Python template Preprocessor for \LaTeX{}. From a source template document \texttt{a.tex} containing specially marked Python code fragments, one or more pure \LaTeX{} files \texttt{a.pyptex} are generated and compiled into final \texttt{a.pdf} documents. Our new approach differs from previous approaches that embedded Python into the \LaTeX{} engine and allowed bidirectional communication between Python and \LaTeX{}. The embedded Python approach exposes users to security risks, but it also has a deadlock problem and is very hard to debug. By contrast, \pyptex{} avoids the security risks of embedded Python, completely eliminates the deadlock problem, and is easy to debug. We have used \pyptex{} to produce a 71-page handout for linear algebra students containing automatically generated problem sets. In combination with SymPy, SciPy and other Python packages, \pyptex{} can be used to create beautiful scientific documents.
\end{abstract}

\section{Introduction}

\pyptex{} is a macro preprocessor (or template engine) for \LaTeX{} \citep{lamport1994latex} that allows one to use the rich Python ecosystem to automate parts of the redaction of sophisticated scientific documents. 
In combination with SciPy \citep{virtanen2020scipy} and SymPy \citep{meurer2017sympy}, \pyptex{} is a powerful tool for generating documents ranging from research papers and books to calculus problem sets for students.

One installs \pyptex{} by typing \texttt{pip install pyptex} at the command prompt. This assumes that one already has working Python and \LaTeX{} installations; by default, \pyptex{} assumes that \texttt{pdflatex} is available at the command line, although alternate \LaTeX{} implementations can also be used. Then, using one's favorite text editor, one places the following text in a file \texttt{example.tex}:
\begin{lstlisting}
\documentclass{article}
@{from sympy import *}
\begin{document}
$$\int x^3\,dx = @{S('integrate(x^3,x)')}+C$$
\end{document}
\end{lstlisting}
One compiles \texttt{example.tex} using the \pyptex{} command line \texttt{pyptex example.tex}. This generates the final output \texttt{example.pdf}, which contains this:
$$\int x^3\,dx = \frac{x^{4}}{4}+C$$
As we can see, SymPy was used to compute an indefinite integral symbolically, and the result was typeset with standard \LaTeX{}.

\pyptex{} also produces the intermediate file \texttt{example.pyptex}, which is a pure-\LaTeX{} file that is useful either for debugging purposes, or for sending a final manuscript to a journal. It contains the following:
\begin{lstlisting}
\documentclass{article}

\begin{document}
$$\int x^3\,dx = \frac{x^{4}}{4}+C$$
\end{document}
\end{lstlisting}
The SymPy Python code in the template file \texttt{example.tex} was executed and replaced with its own output in standard \LaTeX{} notation.
The file \texttt{example.pdf} was automatically generated by \pyptex{} from the \texttt{example.pyptex} file (internally, \pyptex{} invoked the command \texttt{pdflatex example.pyptex}).

\begin{figure}
$$\texttt{a.tex} \implies \text{\pyptex{}} \implies \texttt{a.pyptex} \implies \texttt{pdflatex}\implies \texttt{a.pdf}$$
\caption{Dataflow of a the \pyptex{} Python template Preprocessor. \label{f:pre}}
\end{figure}
\begin{figure}
$$\texttt{a.tex} \implies 
\left\{
\begin{array}{c}
\texttt{pdflatex} \\
\Longupdownarrow \\
\text{Python}
\end{array}
\right\}
\implies \texttt{a.pdf}
$$
\caption{Dataflow when Python is embedded in the \texttt{pdflatex} engine. \label{f:embed}}
\end{figure}

In \pyptex{}, debugging and error handling are first-class citizens. If any errors occur during Python interpretation, \pyptex{} automatically launches the Python debugger Pdb in postmortem mode, just like standard \LaTeX{} enters \texttt{errorstopmode} on error. In Pdb, all standard Python debugging tools work as normal, and source code from the originating \texttt{.tex} file is visible in its context (e.g. with the \texttt{list} command). If an error occurs during \LaTeX{} compilation (e.g. during \texttt{pdflatex example.pyptex}), the usual error prompt is provided by \LaTeX{}.

\pyptex{} is a {\em preprocessor} (or {\em template engine}) for \LaTeX{}, see Figure \ref{f:pre}.
Python fragments are extracted from the (template) source \texttt{a.tex} file by a regular expression pattern matcher, executed by a Python interpreter, and substituted with the appropriate outputs. The collated file is written to disk as \texttt{a.pyptex}, which is a pure \LaTeX{} file. Because this procedure is done by regular expressions, the \LaTeX{} compiler is not invoked and not involved in parsing or processing \texttt{a.tex}. Once \texttt{a.pyptex} has been produced, then \texttt{a.pdf} is obtained, e.g. via \texttt{pdflatex a.pyptex}.

As far as we know, \pyptex{} is the first time that Python is formally used as a preprocessor or templating engine for \LaTeX{}. However, Python has previously been {\em embedded} into \LaTeX{} engines, see Figure \ref{f:embed}; we mention \citet{fine2005tex}, \citet{ehmsen}, \citet{poore2015pythontex}. For SymPy there is \citet{molteno2014sympytex} and for Sage there is \citet{drake2009sagetex}. Other scripting languages have also been embedded into \LaTeX{}, for example Perl \citep{pakin2004perltex} and Lua \citep{hagen2005luatex}. When Python is embedded into \LaTeX{}, all the Python fragments are extracted from a source \texttt{a.tex} file by the \TeX{} macro engine itself. After executing these Python fragments, the relevant outputs are substituted into the macro stream being ``digested'' by the \TeX{} engine \citep{knuth1984texbook}. Although templating engines for \LaTeX{} seem rare, they are commonly used for other document formats, see e.g. \citet{hepple1998}, or \citet{alchin2013pro}. Usually, templating engines focus on generating multiple documents from a single template, whereas \pyptex{} focuses on generating a single document from a template. For that reason, we prefer the terminology ``preprocessor''. That being said, \pyptex{} can indeed be used in a more traditional templating mode where multiple documents are generated from a single template \texttt{a.tex}.

With the help of \pyptex{}, we have produced a 71-page handout \citep{Loisel2020} for the course F19NB at Heriot-Watt University on numerical linear algebra. Previous to \pyptex{}, in 2018, we had used an ad-hoc and highly complex build system for \LaTeX{} code generation. While we distinguish this ad-hoc approach from our new template preprocessor approach, we mention that the ad-hoc generation of \LaTeX{} from pure Python programs is widespread. In 2019, we switched from an ad-hoc approach to PythonTex and it was a significant improvement, but we found three important drawbacks to the embedded Python approach, which motivated us to create \pyptex{}.

First, there is the (somewhat theoretical) security risk of allowing third-party \LaTeX{} packages to execute arbitrary Python codes unbeknownst to the user. Second, there is the issue of ``deadlock'', which is when the source and cache files enter a state where compiling \texttt{a.tex} into \texttt{a.pdf} becomes impossible because of \TeX{} errors. This occurs when the \TeX{} macro processor is simultaneously extracting new Python fragments from \texttt{a.tex} while inserting outdated cached substitutions from a previous version of \texttt{a.tex}. To break deadlock, it is usually necessary to manually delete all cache files, but this is not always sufficient, and sometimes modifying \texttt{a.tex} is necessary. Finally, the third problem is the difficulty of debugging Python fragments and generated \LaTeX{} fragments.

We have found that our new Python template preprocessor \pyptex{} avoids all three problems. First, it does not allow third-party \LaTeX{} packages to execute arbitrary Python codes because there is no bidirectional communication between \LaTeX{} and Python. Second, deadlock is impossible by design because the \LaTeX{} engine is not involved at all in the extraction, execution and substitution of Python fragments from \texttt{a.tex}. Finally, debugging with Pdb is treated as a first-class citizen and works as normal, and the collated \LaTeX{} document is made available in the human-preferred format of a pure-\LaTeX{} source file \texttt{a.pyptex}, as opposed to a ``partially digested'' \TeX{} macro stream. We have confirmed these significant improvements using our F19NB handout, which consists of 2,592 lines and 105KB of \LaTeX{} source in file \texttt{notes.tex}, including 1,256 lines of Python code.

Our paper is organized as follows. In Section 2, we give a brief tour of \pyptex{} features. In Section 3, we discuss the F19NB case study, a 71 page PDF document containing automatically generated problem sets for linear algebra students. We end with some conclusions in Section 4.

\section{A brief tour of \pyptex{} features}

The \texttt{pyptex a.tex} command executes Python fragments in \texttt{a.tex} delimited by either \verb|@{...}| or \verb|@{{{...}}}|; the latter notation is necessary if the Python fragment contains curly braces. If a literal \verb|@{| is needed, it can be escaped by using a double \verb|@@{|; apart from this, it is not necessary to escape \verb|@| symbols. \pyptex{} also honors \LaTeX{}-style comments so that \verb|%@{error}| does not execute the Python expression \verb|error|.

\pyptex{} allows one to execute arbitrary Python programs and import arbitrary Python packages, e.g. \verb|@{from sympy import *}|. One can use SymPy to create simple plots, save them to a file and include them via the standard \LaTeX{} graphicx package. For example:
\lstinputlisting{plot1.tex}
As with all modern template preprocessors, \pyptex{} enables modular development by assembling a project from multiple component files. For example, the preceding plotting snippet was saved in the \texttt{plot1.tex}, which will later be included in our master \texttt{a.tex} via the command
\verb|@{pyp.input('plot1.tex')}|. The files \texttt{a.tex} and \texttt{plot1.tex} are analogous to Python modules in that they execute their own separate namespaces. As such, it is necessary to re-import SymPy into the namespace of \texttt{plot1.tex}, even though it already has been imported into the namespace of the master file \texttt{a.tex}.

The pattern of plotting a figure, saving it to a file, and then including its filename into the generated \texttt{a.pyptex} file is very common, so \pyptex{} includes a convenience function \texttt{pyp.savefig()} that automatically generates distinct numbered filenames under the \texttt{a-generated/*} directory; in the present case, we create the file \texttt{a-generated/fig1.eps} with the following fragment:
\lstinputlisting{plot2.tex}
These plotting commands have also been stored in a separate file \texttt{plot2.tex}.
Note that the Python fragment in \texttt{plot2.tex} consists of two Python statements. The Python programming language distinguishes {\em expressions} that return or produce a value, and typically consist of a single line; and {\em statements} that may run multiple lines and produce no value. The multiple lines in the \texttt{plot2.tex} Python code fragments means that they are statements that produce no value. In order to print the filename \texttt{a-generated/fig1.eps} into the curly braces of the \verb|\includegraphics{...}|, it is therefore required to use the \verb|pyp.print(...)| command.

Embedding the files \texttt{plot1.tex} and \texttt{plot2.tex} via the \texttt{pyp.input(...)} mechanism described above, results in the following output:\\
\noindent \input{plot1.pyptex}
\input{plot2.pyptex}

Standard out and standard error print out to the console as usual, and are additionally logged in the \texttt{a.pyplog} file. If one wishes to print directly to the \texttt{a.pyptex} file, one should use the \texttt{pyp.print()} function.

For performance reasons, \pyptex{} caches the outputs of Python fragments in a binary file \texttt{a.pickle}. If one edits purely textual portions of \texttt{a.tex} while leaving the Python fragments untouched, the cached outputs are used and the production of \texttt{a.pyptex} is nearly instantaneous. If the Python fragments in \texttt{a.tex} are not identical to the cached fragments, or if the command-line arguments to \texttt{pyptex} have changed, or if the \texttt{pyptex} package version has changed, the cache is automatically invalidated. Furthermore, the command \verb|pyp.dep(filename)| can be used to add further dependencies that will invalidate the cache when the file \verb|filename| changes. Any auxiliary \texttt{.tex} files (and their dependencies) incorporated via \verb|pyp.input(...)| are automatically added to the list of dependencies via \verb|pyp.dep()|, but if external data files are \texttt{open()}ed and used to generate, e.g. \LaTeX{} tables, these files should manually be added to the dependencies via \verb|pyp.dep()|. The helper function \verb|pyp.open(...)| automatically calls \verb|pyp.dep(...)| before calling the builtin \verb|open(...)| function.

One can control how the \texttt{a.pyptex} file is compiled into \texttt{a.pdf} by specifying which \LaTeX{} engine to use. To completely disable all \LaTeX{} processing, do \verb|@{pyp.latexcommand=False}| anywhere in \texttt{a.tex}. The default \texttt{latexcommand} is 
\begin{lstlisting}
{latex} {pyptexfilename} && 
   (test ! -f {bibfilename} || bibtex {auxfilename})
\end{lstlisting}
The usual Python substitutions are made from the \texttt{pyp} object, e.g. \verb|pyp.latex| defaults to \verb|"pdflatex --file-line-error --synctex=1"| but this can be overridden from anywhere in \texttt{a.tex}.

\pyptex{} can be used programmatically in the Python interpreter with \texttt{import pyptex}. The module exports a \texttt{pyptex.pyptex} object; doing \\ \texttt{pyp = pyptex.pyptex('a.tex')} causes the file \texttt{a.tex} to be read in, the Python fragments are executed, and the file \texttt{a.pyptex} is written out. The compiled text \texttt{a.pyptex} is available as the string \texttt{pyp.compiled}. The function \\\texttt{pyptex.pyptexmain()} implements the standard operations of the shell command \texttt{pyptex}. Further documentation is available by doing e.g. \texttt{help(pyptex)}.

On Mac, \pyptex{} can be used with TeXShop by creating the file \\ \verb|~/Library/TeXShop/Engines/pyptex.engine| with the following contents:
\begin{lstlisting}
#!/bin/bash
pyptex $1
\end{lstlisting}
Upon restarting TeXShop, this adds the \texttt{pyptex} build option to the list of build engines.
%\lstinputlisting{~/Library/TeXShop/Engines/pyptex.engine}

\section{Case study: the F19NB handout}

At Heriot-Watt University, F19NB is a course on numerical linear algebra for undergraduate students. Topics include Gaussian elimination, classical iterations (Jacobi and SOR), GMRES and the QR iteration. All of the theory, proofs, examples and exercises are collected in a 71-page handout. Many of the numerical exercises and their solutions are automatically generated. For some problems (e.g. eigenvalue problems, where the characteristic polynomial must be obtained), it is helpful to do a little bit of symbolic calculations using SymPy. Other exercises and examples are more numerical and use numpy and matplotlib for displaying solutions.

As of this writing, there are 2,592 lines and 105KB\footnote{As usual, some \LaTeX{} lines can be very long or very short, so the size of the file in KB may be more indicative of the size of the project} in the source file \texttt{notes.tex}, of which 1,256 lines are Python scripts. However, up to 2018, the \texttt{notes.tex} file did not contain any Python code. The Python codes were stored in separate \texttt{.py} files under a \texttt{problib} directory. These problem sets were spread over 24 Python source files and 1,268 lines of Python code. The \texttt{problib} codes were executed in sequence and all the outputs collected in an automatically generated 1,211 line (78KB) \texttt{problems.tex} file. The file \texttt{problems.tex} is a pure \LaTeX{} file that contains problem questions and solutions, encapsulated in \verb|\newcommand| statements, and is then included in the main \texttt{notes.tex} file via the \verb|\input{problems.tex}| mechanism. Various problems and their solutions can then be instantiated in the \texttt{notes.tex} file by invoking the corresponding \LaTeX{} commands.

The sheer number of files and building steps caused an explosion in complexity more typical of software engineering than mathematical typesetting. Identifying which Python code generated any particular problem set was becoming increasingly challenging. On occasions, it was found that \texttt{problems.tex} was inconsistent with the \texttt{problib} Python scripts, either because the \texttt{problib} Python scripts had not been rerun, or sometimes because a Python script had accidentally been deleted. Fixing these issues was taking an increasing amount of the author's time.

\subsection{PythonTex and \texttt{notes.tex}}

In 2019, we adopted PythonTex and it was a major success. This allowed us to immediately reduce the number of external Python scripts and build steps, because many of the simpler tasks could be done directly from \texttt{notes.tex}. By the end of 2019, all Python scripts were moved to \texttt{notes.tex}, and \texttt{problib} was deleted.

Despite these major improvement, new ``software engineering-style'' problems arose. In the abstract, allowing third-party \LaTeX{} packages to execute arbitrary Python programs seems like a security problem. As of this writing, there are 7,093 potentially malicious \LaTeX{} packages on CTAN. That being said, there are 211,855 packages currently on the Python archive PyPI, and malicious Python packages are regularly identified, e.g. \citet{cimpanu2018twelve}. Ultimately, it was the deadlock and debugging problems that motivated us to create \pyptex{}.

We now list a few examples of deadlock situations, inspired from deadlocks that happened during the development of \texttt{notes.tex}. First, if some Python fragment in \texttt{notes.tex} generates the image \texttt{dog.png}, then the \LaTeX{} command \verb|\includegraphics{dog.png}| will fail on first execution because PythonTex has not yet executed the Python code that generates \texttt{dog.png}. Because the first execution of \verb|pdflatex| has failed, the Python code to generate \verb|dog.png|. Repeatedly invoking \verb|pdflatex| or \verb|pythontex|, or deleting cache and aux files, does not break the deadlock. One must modify \texttt{notes.tex} so that it does not cause an error when the file \texttt{dog.png} does not exist. Furthermore, if the filename for the \verb|includegraphics| is generated programmatically, e.g. \\ \verb|\includegraphics{\py{"dog.png"}}|, then when there is no cache, \texttt{pdflatex} is likely to fail because \verb|\py{"dog.png"}| will macro-expand to the empty string, causing an error. One can ``prime'' the cache by temporarily deleting the \verb|\includegraphics|. After reinserting the \verb|\includegraphics|, \texttt{notes.tex} will compile successfully, but deleting the cache or \texttt{dog.png} will cause a compilation failure/deadlock again.
We also found that PythonTex often tried to substitute mismatched cache outputs to various input Python fragments.
We are not entirely certain how PythonTex keeps track of matching inputs and outputs in the cache, but it seemed to us that adding or deleting a Python code fragment \verb|\py{...}| almost always resulted in deadlock and having to delete all cache files. Of course, deleting all cache files itself sometimes caused deadlock elsewhere.

Practically speaking, we found that almost any significant and even minor edit to \texttt{notes.tex} resulted in deadlock and had to be accompanied with a manual deletion of all temporary files, and further tweaks to \texttt{notes.tex} that are required by the deletion of the cache files.

We found it difficult to debug Python code fragments in \texttt{notes.tex} because PythonTex actually executes Python fragments stored in some temporary files that PythonTex aggressively deletes, not straight from \texttt{notes.tex}. Furthermore, the Python interpreter often declared incorrectly that syntax errors were located in PythonTex glue code that is inserted between extracted Python fragments. Although PythonTex attempts to reconcile line numbers between \texttt{notes.tex} and the various temporary files, we found that this simply led to more confusion and difficulties in debugging.

The generated \LaTeX{} is merged into the \TeX{} token stream from various temporary files, so there is no collated file similar to the \texttt{notes.pyptex} of \pyptex{}. It seemed to us that \TeX{} was struggling to provide informative error messages, and it was difficult to view generated \LaTeX{} fragments in context. We resorted to manually copy-and-pasting generated \LaTeX{} fragments from various temporary files into \texttt{notes.tex}.

Altogether, debugging was challenging. Issues had to be identified and isolated by searching through multiple temporary files, and then locating the corresponding source in \texttt{notes.tex}.

\subsection{The invention of \pyptex{}.}

If the motivation of upgrading from ad-hoc scripting to PythonTex was to mitigate the burgeoning software engineering challenges in our old build process, then the motivation for moving to \pyptex{} was to address the perceived drawbacks of PythonTex: deadlock issues, and ease of debugging.

Our starting point was that \TeX{} was not a good tool for the end-to-end process of extracting Python fragments from a template file, replacing them with their outputs and compiling the whole thing down into a PDF. When \TeX{} is performing the extraction task, if it is also simultaneously performing insertions from cache files, deadlock seems almost inevitable. \TeX{} must clearly be used to generate the PDF so it seemed natural to cut \TeX{} out of the beginning of the process, when the Python fragments are extracted from the \texttt{notes.tex} file. From this insight, we concluded we had to abandon the Python Embedding approach, in favor of the Python template Preprocessor approach.

We have successfully used \pyptex{} for the 2020 version of the F19NB handout
and found that \pyptex{} has the following advantages over PythonTex:
\begin{enumerate}
\item {\bf No deadlock.} \pyptex{} is always able to either generate \texttt{notes.pyptex} from \texttt{notes.tex}, regardless of any cache contents, or report genuine Python errors in the source file \texttt{notes.tex}.
\item {\bf Easy to debug Python.} When \pyptex{} does report genuine Python errors in \texttt{notes.tex}, the error messages are clear and Python debugging is done directly in the source \texttt{notes.tex} file using standard Python tools such as Pdb. There is no auxiliary file for collecting Python code fragments, and no confusion between various line numberings. There is no glue code inserted between Python fragments, and hence Python errors are always correctly reported inside user codes.
\item {\bf Easy to debug generated \LaTeX{}.} Debugging the generated \LaTeX{} code \texttt{notes.pyptex} is much easier, as it consists entirely of high-level, human-readable \LaTeX{} code, as opposed to a partially digested \TeX{} token stream that is difficult to debug for all but the most advanced \TeX{}nicians.
All \LaTeX{} error messages correspond exactly to the contents of \texttt{notes.pyptex} and its line numbers.
\item {\bf Security.} Third-party \LaTeX{} packages cannot execute arbitrary Python code on the user's machine.
\end{enumerate}
One can regard the \texttt{notes.pyptex} as an intermediate file that the user will occasionally have to inspect in order to debug generated \LaTeX{} fragments, and the experience of PythonTex is that such temporary user-facing files must be carefully thought through lest they become a source of problems. By only generating one such user-facing intermediate file, our experience with \texttt{notes.pyptex} is that we have avoided most of the problems we had tracking information across multiple temporary files in PythonTex. In addition, unlike PythonTex, our intermediate file \texttt{notes.pyptex} is designed to be used first by humans, and secondarily by the \LaTeX{} compiler. This is because \texttt{notes.pyptex} consists of high-level, human-style \LaTeX{} source commands, and not some low-level macro-expansion of the high-level \LaTeX{} source.

In addition to the user-facing file \texttt{notes.pyptex}, \pyptex{} also produces a plain-text log file \texttt{notes.pyplog}, and a cache file \texttt{notes.pickle} that is in binary format and opaque to users. In our experience, we never had to manually inspect the contents of \texttt{notes.pickle} and this file never caused deadlock or debugging problems in \pyptex{}. Furthermore, \texttt{notes.pickle} can also be deleted without breaking the build. In extremis, \texttt{notes.pickle} can theoretically be loaded and inspected using Python's pickle module, but we have never needed to do this.

Theoretically, an outdated \texttt{notes.pickle} cache could cause the a miscompilation of \texttt{notes.pyptex} and produce an incorrect \texttt{notes.pdf}, or even a \LaTeX{} compilation error. The previously-described dependency-tracking features of \pyptex{} are almost always able to detect that the cache should be invalidated, but a sufficiently determined user could defeat these safety measures. For example, if a user is reading data from a file without declaring it as a dependency, or if a user is falsifying ``last modification'' timestamps on files,
or generating random numbers, or some other form of nondeterminism is taking place, then cache invalidation may fail. A concerned user can completely disable the \texttt{notes.pickle} cache file by issuing the Python command \verb|pyp.disable_cache=True| in \texttt{notes.tex}, trading efficiency for safety.

\section{Conclusions and outlook}

We have introduced \pyptex{}, the Python template Preprocessor for \LaTeX{}. Unlike other projects that have embedded Python into \LaTeX{}, \pyptex{} uses regular expressions to extract Python fragments and substitute their outputs. Our preprocessor approach is superior to the embedded approach because it avoids the deadlock and debugging issues that plague embedded Python approaches, and it also eliminates the attack vector of arbitrary code execution by malicious third-party \LaTeX{} packages. \pyptex{} has been used to generate problem sets for the F19NB class at Heriot-Watt University. This large 71-page document features 1,256 lines of Python in a 105KB source file \texttt{notes.tex}.

\pyptex{} centers around the Python programming language, but one could extend on our idea by adding more languages to the preprocessor, e.g. the string \verb|@julia{...}| could invoke a Julia interpreter. This poses a challenging issue of how to tightly integrate any such ``guest language'', and particularly its native debugging tools, so that the user experience is best possible. The tight integration of Python's Pdb debugger, and the deliberate cache invalidation algorithm, required careful use of Python's extensive introspection and detailed code generation facilities. This is an avenue for future research.

\bibliographystyle{plainnat}

\bibliography{test}
\end{document}
