<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pyptex API documentation</title>
<meta name="description" content="PypTeX: the Python Preprocessor for TeX …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>pyptex</code></h1>
</header>
<section id="section-intro">
<h2 id="pyptex-the-python-preprocessor-for-tex">PypTeX: the Python Preprocessor for TeX</h2>
<h3 id="author-sebastien-loisel">Author: Sébastien Loisel</h3>
<p>PypTeX is the Python Preprocessor for LaTeX. It allows one to embed Python
code fragments in a LaTeX template file.</p>
<h1 id="installation">Installation</h1>
<p><code>pip install <a title="pyptex.pyptex" href="#pyptex.pyptex">pyptex</a></code></p>
<ol>
<li>You will also need a LaTeX installation, and the default LaTeX processor is <code>pdflatex</code>.</li>
<li>You need a Python 3 installation.</li>
</ol>
<p><img alt="An example plot with PypTeX" width="500" src="examples/brochure.png"></p>
<h1 id="introduction">Introduction</h1>
<p>Assume <code>example.tex</code> contains the following text:</p>
<pre><code>\documentclass{article}
@{from sympy import *}
\begin{document}
$$\int x^3\,dx = @{S('integrate(x^3,x)')}+C$$
\end{document}
</code></pre>
<p>The command <code><a title="pyptex.pyptex" href="#pyptex.pyptex">pyptex</a> example.tex</code> will generate <code>example.pdf</code>,
as well as the intermediary file <code>example.pyptex</code>. PypTeX works by extracting Python
fragments in <code>example.tex</code> indicated by either <code>@{...}</code> or <code>@{{{...}}}</code> and substituting the
corresponding outputs to produce <code>example.pyptex</code>, which is then compiled with
<code>pdflatex example.pyptex</code>, although one can use any desired LaTeX processor in lieu of
<code>pdflatex</code>. The intermediary file <code>example.pyptex</code> is pure LaTeX.</p>
<p>When processing Python fragments, the global scope contains an object <code>pyp</code> that is a
(weakref proxy for a) <code><a title="pyptex.pyptex" href="#pyptex.pyptex">pyptex</a></code> object that makes available several helper functions
and useful data. For example, <code>pyp.print("hello, world")</code> inserts the string <code>hello, world</code>
into the generated <code>example.pyptex</code> file.</p>
<ul>
<li>The <code><a title="pyptex.pyptex" href="#pyptex.pyptex">pyptex</a></code> executable tries to locate the Python 3 executable using <code>/usr/bin/env python3</code>.
If this is causing you problems, try <code>python -u -m pyptex example.tex</code> instead.</li>
</ul>
<h1 id="slightly-bigger-examples">Slightly bigger examples</h1>
<ul>
<li>2d and 3d plotting <a href="examples/plots.tex">tex</a>
|
<a href="examples/plots.pdf">pdf</a></li>
<li>Matrix inverse exercise <a href="examples/matrixinverse.tex">tex</a>
|
<a href="examples/matrixinverse.pdf">pdf</a></li>
<li>The F19NB handout for numerical linear algebra at Heriot-Watt university is generated with PypTeX. <a href="https://www.macs.hw.ac.uk/~sl398/notes.pdf">pdf</a></li>
</ul>
<h1 id="plotting-with-sympy-and-matplotlib">Plotting with <code>sympy</code> and <code>matplotlib</code></h1>
<p>PypTeX implements its own <code>matplotlib</code> backend, a thin wrapper around the built-in postscript backend.
The PypTeX backend takes care of generating <code>.eps</code> files and importing them into your document via
<code>\includegraphics</code>. In that scenario, you must do <code>\usepackage{graphicx}</code> in your LaTeX preamble.
The precise "includegraphics" command can be set, e.g. by
<code>pyp.includegraphics=r"\includegraphics[width=0.9\textwidth]{%s}"</code>.</p>
<p>To create a plot with <code>sympy</code>, one can do:</p>
<pre><code class="language-python">sympy.plot(sympy.S('sin(x)+cos(pi*x)'))
</code></pre>
<p>At the end of each Python fragment <code>@{...}</code>, PypTeX saves each generated figure to a
<code>x.eps</code> file, and these figures are then inserted via <code>includegraphics</code> into the generated
<code>.tex</code> file. Once a figure has been auto-showed in this manner, it will not be
auto-showed again. The auto-show behavior can be disabled by setting <code>pyp.autoshow = False</code>.
Figures can also be displayed manually via <code>pyp.pp('{myfig})</code>.</p>
<pre><code class="language-python">plt.plot([1,2,3],[2,1,4])
</code></pre>
<h1 id="template-preprocessing-vs-embedding">Template preprocessing vs embedding</h1>
<p>PypTeX is a template preprocessor for LaTeX based on the Python language. When Python
is embedded into LaTeX, Python code fragments are identified by LaTeX commands that use
standard TeX notation, such as <code>\py{...}</code>. The code extraction is performed by TeX, then
the code fragments are executed by Python, finally TeX is run again to merge the
Python-generated LaTeX fragments back into the master file.</p>
<p>By contrast, PypTeX is a preprocessor that extracts Python code fragments indicated by
<code>@{...}</code> using regular expressions. Once the relevant Python outputs are collected, they
are also inserted by regular expressions. LaTeX is only invoked once, on the final output.</p>
<p>There may be specialized cases where Python embeddings are preferred, but we found
that template preprocessing is superior to embedding. There are many reasons (that
will be described elsewhere in detail) but we briefly mention the following reasons:
1. Embeddings can result in deadlock. If we have <code>\includegraphics{dog.png}</code>, but
<code>dog.png</code> is generated by a Python fragment, the first run of LaTeX will fail because
<code>dog.png</code> does not yet exist. Since LaTeX failed, it did not extract the Python fragments
and we cannot run the Python code that would generate <code>dog.png</code> unless we temporarily
delete the <code>\includegraphics{dog.png}</code> from <code>a.tex</code>. In our experience, deadlock
occurs almost every time we edit our large <code>.tex</code> files.
2. Embedding makes debugging difficult. By contrast, PypTeX treats Python's debugger Pdb
as a first-class citizen and everything should work as normal. Please let us know if some
debugging task somehow fails for you.
3. Performance. Substituting using regular expressions is faster than running the
LaTeX processor.</p>
<h1 id="pretty-printing-template-strings-from-python-with-pp">Pretty-printing template strings from Python with <code>pp</code></h1>
<p>The function <code>pyp.pp(X)</code> pretty-prints the template string <code>X</code> with substitutions
from the local scope of the caller. This is useful for medium length LaTeX fragments
containing a few Python substitutions:</p>
<pre><code class="language-python">from sympy import *
p = S('x^2-2*x+3')
dpdx = p.diff(S('x'))
pyp.print(pyp.pp('The minimum of $y=@p$ is at $x=@{solve(dpdx)[0]}$.'))
</code></pre>
<h1 id="caching">Caching</h1>
<p>When compiling <code>a.tex</code>, PypTeX creates a cache file <code>a.pickle</code>. This file is
automatically invalidated if the Python fragments in <code>a.tex</code> change, or if some
other dependencies have changed. Dependencies can be declared from inside <code>a.tex</code> via
<code>pyp.dep(&hellip;)</code>. Caching can be completely disabled with <code>pyp.disable_cache=True</code>,
and users can delete <code>a.pickle</code> as necessary.</p>
<h1 id="scopes">Scopes</h1>
<p>For each template file <code>a.tex</code>, <code>b.tex</code>, &hellip; a private global scope is created for
executing Python fragments. This means that Python fragments in <code>a.tex</code> cannot use
functions or variables defined in <code>b.tex</code>, although shared functions could be
implemented in a shared <code>c.py</code> Python module that is <code>import</code>ed into
<code>a.tex</code> and <code>b.tex</code>.</p>
<p>In particular, when does <code>pyp.input('b.tex')</code> from <code>a.tex</code>, the code in <code>b.tex</code> cannot
use functions and data generated in <code>a.tex</code>. This means that <code>b.tex</code> is effectively
a "compilation unit" whose semantics are essentially independent of <code>a.tex</code>.</p>
<p>For any given <code>a.tex</code> file, its private global scope is initialized with the
standard Python builtins and with a single <code>pyp</code> object, which is a <code>weakref.proxy</code>
to the <code>pyptex('a.tex')</code> instance. We use a <code>weakref.proxy</code> because the global
scope of <code>a.tex</code> is a <code>dict</code> stored in the (private) variable <code>pyp.__global__</code>. The
use of <code>weakref.proxy</code> avoids creating a circular data structure that would otherwise
stymie the Python garbage collector. For most purposes, this global <code>pyp</code> variable
acts exactly like a concrete <code><a title="pyptex.pyptex" href="#pyptex.pyptex">pyptex</a></code> instance.</p>
<h1 id="texshop">TeXShop</h1>
<p>If you want to use TeXShop on Mac, put the following into <code>~/Library/TeXShop/Engines/pyptex.engine</code> and restart TeXShop:</p>
<pre><code>#!/bin/bash
pyptex $1
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">r&#34;&#34;&#34;
## PypTeX: the Python Preprocessor for TeX

### Author: Sébastien Loisel

PypTeX is the Python Preprocessor for LaTeX. It allows one to embed Python
code fragments in a LaTeX template file.

# Installation

`pip install pyptex`

1. You will also need a LaTeX installation, and the default LaTeX processor is `pdflatex`.
2. You need a Python 3 installation.

&lt;img alt=&#34;An example plot with PypTeX&#34; width=&#34;500&#34; src=&#34;examples/brochure.png&#34;&gt;

# Introduction

Assume `example.tex` contains the following text:

    \documentclass{article}
    @{from sympy import *}
    \begin{document}
    $$\int x^3\,dx = @{S(&#39;integrate(x^3,x)&#39;)}+C$$
    \end{document}

The command `pyptex example.tex` will generate `example.pdf`,
as well as the intermediary file `example.pyptex`. PypTeX works by extracting Python
fragments in `example.tex` indicated by either `@{...}` or `@{{{...}}}` and substituting the
corresponding outputs to produce `example.pyptex`, which is then compiled with
`pdflatex example.pyptex`, although one can use any desired LaTeX processor in lieu of
`pdflatex`. The intermediary file `example.pyptex` is pure LaTeX.

When processing Python fragments, the global scope contains an object `pyp` that is a
(weakref proxy for a) `pyptex.pyptex` object that makes available several helper functions
and useful data. For example, `pyp.print(&#34;hello, world&#34;)` inserts the string `hello, world`
into the generated `example.pyptex` file.

* The `pyptex` executable tries to locate the Python 3 executable using `/usr/bin/env python3`.
If this is causing you problems, try `python -u -m pyptex example.tex` instead.

# Slightly bigger examples

* 2d and 3d plotting [tex](examples/plots.tex)
|
[pdf](examples/plots.pdf)
* Matrix inverse exercise [tex](examples/matrixinverse.tex)
|
[pdf](examples/matrixinverse.pdf)
* The F19NB handout for numerical linear algebra at Heriot-Watt university is generated with PypTeX. [pdf](https://www.macs.hw.ac.uk/~sl398/notes.pdf)

# Plotting with `sympy` and `matplotlib`

PypTeX implements its own `matplotlib` backend, a thin wrapper around the built-in postscript backend.
The PypTeX backend takes care of generating `.eps` files and importing them into your document via
`\includegraphics`. In that scenario, you must do `\usepackage{graphicx}` in your LaTeX preamble.
The precise &#34;includegraphics&#34; command can be set, e.g. by
`pyp.includegraphics=r&#34;\includegraphics[width=0.9\textwidth]{%s}&#34;`.

To create a plot with `sympy`, one can do:
```python
sympy.plot(sympy.S(&#39;sin(x)+cos(pi*x)&#39;))
```
At the end of each Python fragment `@{...}`, PypTeX saves each generated figure to a
`x.eps` file, and these figures are then inserted via `includegraphics` into the generated
`.tex` file. Once a figure has been auto-showed in this manner, it will not be
auto-showed again. The auto-show behavior can be disabled by setting `pyp.autoshow = False`.
Figures can also be displayed manually via `pyp.pp(&#39;{myfig})`.

```python
plt.plot([1,2,3],[2,1,4])
```

# Template preprocessing vs embedding

PypTeX is a template preprocessor for LaTeX based on the Python language. When Python
is embedded into LaTeX, Python code fragments are identified by LaTeX commands that use
standard TeX notation, such as `\py{...}`. The code extraction is performed by TeX, then
the code fragments are executed by Python, finally TeX is run again to merge the
Python-generated LaTeX fragments back into the master file.

By contrast, PypTeX is a preprocessor that extracts Python code fragments indicated by
`@{...}` using regular expressions. Once the relevant Python outputs are collected, they
are also inserted by regular expressions. LaTeX is only invoked once, on the final output.

There may be specialized cases where Python embeddings are preferred, but we found
that template preprocessing is superior to embedding. There are many reasons (that
will be described elsewhere in detail) but we briefly mention the following reasons:
1. Embeddings can result in deadlock. If we have `\includegraphics{dog.png}`, but
`dog.png` is generated by a Python fragment, the first run of LaTeX will fail because
`dog.png` does not yet exist. Since LaTeX failed, it did not extract the Python fragments
and we cannot run the Python code that would generate `dog.png` unless we temporarily
delete the `\includegraphics{dog.png}` from `a.tex`. In our experience, deadlock
occurs almost every time we edit our large `.tex` files.
2. Embedding makes debugging difficult. By contrast, PypTeX treats Python&#39;s debugger Pdb
as a first-class citizen and everything should work as normal. Please let us know if some
debugging task somehow fails for you.
3. Performance. Substituting using regular expressions is faster than running the
LaTeX processor.

# Pretty-printing template strings from Python with `pp`

The function ```pyp.pp(X)``` pretty-prints the template string `X` with substitutions
from the local scope of the caller. This is useful for medium length LaTeX fragments
containing a few Python substitutions:
```python
from sympy import *
p = S(&#39;x^2-2*x+3&#39;)
dpdx = p.diff(S(&#39;x&#39;))
pyp.print(pyp.pp(&#39;The minimum of $y=@p$ is at $x=@{solve(dpdx)[0]}$.&#39;))
```

# Caching

When compiling `a.tex`, PypTeX creates a cache file `a.pickle`. This file is
automatically invalidated if the Python fragments in `a.tex` change, or if some
other dependencies have changed. Dependencies can be declared from inside `a.tex` via
`pyp.dep(...)`. Caching can be completely disabled with `pyp.disable_cache=True`,
and users can delete `a.pickle` as necessary.

# Scopes

For each template file `a.tex`, `b.tex`, ... a private global scope is created for
executing Python fragments. This means that Python fragments in `a.tex` cannot use
functions or variables defined in `b.tex`, although shared functions could be
implemented in a shared `c.py` Python module that is `import`ed into
`a.tex` and `b.tex`.

In particular, when does `pyp.input(&#39;b.tex&#39;)` from `a.tex`, the code in `b.tex` cannot
use functions and data generated in `a.tex`. This means that `b.tex` is effectively
a &#34;compilation unit&#34; whose semantics are essentially independent of `a.tex`.

For any given `a.tex` file, its private global scope is initialized with the
standard Python builtins and with a single `pyp` object, which is a `weakref.proxy`
to the `pyptex(&#39;a.tex&#39;)` instance. We use a `weakref.proxy` because the global
scope of `a.tex` is a `dict` stored in the (private) variable `pyp.__global__`. The
use of `weakref.proxy` avoids creating a circular data structure that would otherwise
stymie the Python garbage collector. For most purposes, this global `pyp` variable
acts exactly like a concrete `pyptex` instance.

# TeXShop

If you want to use TeXShop on Mac, put the following into `~/Library/TeXShop/Engines/pyptex.engine` and restart TeXShop:
```
#!/bin/bash
pyptex $1
```
&#34;&#34;&#34;

from contextlib import suppress
import datetime
import glob
import inspect
import os
import pickle
import re
import string
import subprocess
import sys
import time
import traceback
import weakref
import streamcapture
import numpy
import sympy
import types
import matplotlib
import matplotlib.pyplot
import matplotlib.artist
from pathlib import Path
from matplotlib.backend_bases import Gcf, FigureManagerBase
from matplotlib.backends.backend_ps import FigureCanvasPS

__pdoc__ = {
    &#39;pyptex.compile&#39;: False,
    &#39;pyptex.generateddir&#39;: False,
    &#39;pyptex.process&#39;: False,
    &#39;pyptex.resolvedeps&#39;: False,
    &#39;pyptex.run&#39;: False,
    &#39;FigureManager&#39;: False,
    &#39;FigureManager.show&#39;: False,
}

__pdoc__[&#39;pyptexNameSpace&#39;] = False
class pyptexNameSpace:
    def __init__(self,d):
        self.__dict__.update(d)
    def __str__(self):
        return fr&#39;\input{{{self.pyp.pyptexfilename}}}&#39;
    def __repr__(self):
        return repr(str(self))
    def __eq__(self, other):
        if isinstance(self, pyptexNameSpace) and isinstance(other, pyptexNameSpace):
           return self.__dict__ == other.__dict__
        return NotImplemented

######################################################################
# The stuff below makes pyptex into a matplotlib backend
FigureCanvas = FigureCanvasPS

class FigureManager(FigureManagerBase):
    def show(self, **kwargs):
        pass

__pdoc__[&#39;show&#39;] = False
def show(*args, **kwargs):
    pass

ppparser = re.compile(r&#34;(@@)|@([a-zA-Z_][a-zA-Z0-9_]*)|@{([^{}}]*)}&#34;,re.DOTALL)
pypparser = re.compile(r&#39;((?&lt;!\\)%[^\n]*\n)|(@@)|(@(\[([a-zA-Z]*)\])?{([^{}]+)}|@(\[([a-zA-Z]*)\])?{{{(.*?)}}})&#39;, re.DOTALL)
bibentryname = re.compile(r&#39;[^{]*{([^,]*),&#39;, re.DOTALL)
stripext = re.compile(r&#39;(.*?)(\.(pyp\.)?[^\.]*)?$&#39;, re.DOTALL)
__stringtag__ = &#34;&lt;PypTeX Format String&gt;&#34;

__pdoc__[&#39;format_my_nanos&#39;] = False
# Credit: abarnet on StackOverflow
def format_my_nanos(nanos: int):
    &#34;&#34;&#34;Convert nanoseconds to a human-readable format&#34;&#34;&#34;
    dt = datetime.datetime.fromtimestamp(nanos / 1e9)
    return &#39;{}.{:09.0f}&#39;.format(dt.strftime(&#39;%Y-%m-%d@%H:%M:%S&#39;), nanos % 1e9)


__pdoc__[&#39;dictdiff&#39;] = False
def dictdiff(A, B):
    A = set(A.items())
    B = set(B.items())
    D = A ^ B
    if len(D) == 0:
        return None
    return next(iter(D))

__pdoc__[&#34;filter_exception&#34;] = False
def filter_exception(e):
    global __stringtag__
    tb = e.__traceback__
    if tb is None:
        return e
    me = tb.tb_frame.f_code.co_filename
    while tb.tb_next is not None:
        code0 = tb.tb_frame.f_code
        code1 = tb.tb_next.tb_frame.f_code
        if code1.co_filename == me or code1.co_filename == __stringtag__:
            tb.tb_next = tb.tb_next.tb_next
        else:
            tb = tb.tb_next
    return e.with_traceback(e.__traceback__.tb_next)

__pdoc__[&#34;__format_exception__&#34;] = False
def __format_exception__(e): # This is a workaround for broken things in Python 3.9
    return &#39;\n&#39;.join(traceback.TracebackException(
                type(e), e, e.__traceback__,limit=None,compact=True).format())

__pdoc__[&#39;exec_and_catch&#39;] = False
def exec_and_catch(cmd,glob,loc,filename,linecount,modes=[eval,exec]):
  for k in range(len(modes)):
    mode = modes[k]
    modename = &#39;exec&#39; if mode==exec else &#39;eval&#39;
    if k&lt;len(modes)-1:
        try:
            C = compile((&#39;\n&#39;*linecount)+cmd,filename,mode=modename)
        except Exception:
            continue
    else:
        C = compile((&#39;\n&#39;*linecount)+cmd,filename,mode=modename)
    ret = mode(C,glob,loc)
    return (ret,mode)

class pyptex:
    r&#34;&#34;&#34;Class `pyptex.pyptex` is used to parse an input (templated) `a.tex` file
    and produce an output `a.pyptex` file, and can be used as follows:
        `pyp = pyptex(&#39;a.tex&#39;)`
    The constructor reads `a.tex`, executes Python fragments and performs relevant
    substitutions, writing `a.pyptex` to disk. The contents of `a.pyptex` are also
    available as `pyp.compiled`.
    &#34;&#34;&#34;

    def genname(self, pattern: str = &#39;fig{gencount}.eps&#39;):
        r&#34;&#34;&#34;Generate a filename

        To produce an automatically generated filename, use the statement
        `pyp.genname()`, where `pyp` is an object of type `pyptex`, for parsing a
        given file `a.tex`. By default, this will generate the name
        `&#39;a-generated/fig{gencount}.eps&#39;`.
        The subdirectory can be overridden by overwriting `pyp.gendir`,
        and `gencount` denotes `pyp.gencount`. Any desired pattern can be used,
        for example:
            `name = pyp.genname(&#39;hello-{gencount}-{thing}.txt&#39;)`
        will return something like `&#39;a-generated/hello-X-Y.txt&#39;`, where
        `X` is `pyp.gencount` and `Y` is `pyp.thing`.

        `pyp.genname()` does not actually create the file. `pyp.genname()` increments
        `pyp.gencount` every time it is called.
        &#34;&#34;&#34;
        self.gencount += 1
        return f&#39;{self.gendir}/{pattern.format(**self.__dict__)}&#39;

    def __setupfig__(self, fig):
        if not hasattr(fig,&#39;__FIGNAME__&#39;):
            figname = self.genname()
            Path(figname).touch()
            self.dep(figname)
            fig.__FIGNAME__ = figname
        if not hasattr(fig,&#39;__IG__&#39;):
            fig.__IG__ = (self.includegraphics%figname)
        if not hasattr(fig,&#39;drawn&#39;):
            fig.drawn = False
        return fig.__IG__
    def showall(self):
        for num, figmanager in enumerate(Gcf.get_all_fig_managers()):
            fig = figmanager.canvas.figure
            self.__setupfig__(fig)
            if fig.drawn:
                pass
            else:
                self.print(fig)

    def generateddir(self):
        &#34;&#34;&#34;This is an internal function that creates the generated directory.&#34;&#34;&#34;
        self.gendir = f&#39;{self.filename}-generated&#39;
        if not os.path.exists(self.gendir):
            os.makedirs(self.gendir)
        self.gencount = 0
    def freeze(self):
        &#34;&#34;&#34;&#39;Freezes&#39; the global scope of the caller by performing a shallow copy and copying it to 
        `pyp.__frozen__`

        See also `pyptex.clear()`&#34;&#34;&#34;
        self.__frozen__ = inspect.stack()[1][0].f_globals.copy()
    def clear(self):
        &#34;&#34;&#34;Clears all global variable.

        pyptex.clear() clears all the global variables of the caller. Example usage:
        ```python
        a = 1
        print(a)      # this prints 1
        pyp.clear()
        print(a)      # this raises an exception because
                      # a is now undefined.
        ```
        
        The global scope is restored from the dictionary `pyp.__frozen__`, which initially only contains
        the pyp object and the `__builtins__` module. One can add more items to the `__frozen__` dict, e.g.
        by importing some standard module. For example,

        ```python
        my_variable = 78
        import sys
        pyp.freeze()     # This freezes my_variable and sys.
        foo = 1          # Now foo is defined...
        pyp.clear()
        # ...Now foo is undefined, but my_variable is still 78,
        # and the sys module is still available.
        ```

        Note that `pyp.freeze()` performs a shallow copy, so:
        ```python
        a = [1,2,3]
        pyp.freeze()  # a = [1,2,3] is now in the frozen scope.
        a[1] = 7      # Now a = [1,7,3] in the global scope.
        pyp.clear()
        # Still a = [1,7,3] because the scope copy was shallow.
        ```
        &#34;&#34;&#34;
        foo = self.__frozen__
        bar = inspect.stack()[1][0].f_globals
        for k,v in foo.items():
            bar[k] = v
        kk = list(bar.keys())
        for k in kk:
            if k not in foo:
                del bar[k]

    def __init__(self, texfilename, argv=None, latexcommand=False):
        r&#34;&#34;&#34;`pyp = pyptex(&#39;a.tex&#39;)` reads in the LaTeX file a.tex and locates all
        Python code fragments contained inside. These Python code fragments are
        executed and their outputs are substituted to produce the `a.pyptex` output file.

        `pyp = pyptex(&#39;a.tex&#39;, argv)` passes &#34;command-line arguments&#34;. The pyptex
        command-line passes `sys.argv[2:]` for this parameter. If omitted, `argv`
        defaults to `[]`. If using PypTeX as an templating engine to generate
        multiple documents from a single source `a.tex` file, one should use
        the `argv` parameter to pass in the various side-parameters needed to generate
        each document. For example, `a.tex` might have the line &#34;Dear @{pyp.argv[0]}&#34;&#34;
        One could produce a letter to John by doing `pyp = pyptex(&#39;a.tex&#39;, [&#39;John&#39;])`.

        `pyp = pyptex(&#39;a.tex&#39;, argv, latexcommand)` further executes a specific shell
        command once `a.pyptex` has been written to disk (e.g. `pdflatex {pytexfilename}`).
        The default value of `latexcommand` is `False`, in which case no shell command
        is executed.

        Some salient fields of the `pyp=pyptex(&#39;a.tex&#39;)` class are:

        * `pyp.filename = &#39;a&#39;` (so `a.tex`, with the extension stripped).
        * `pyp.texfilename = &#39;a.tex&#39;`.
        * `pyp.cachefilename = &#39;a.pickle&#39;`.
        * `pyp.bibfilename = &#39;a.bib&#39;`, used by the `pyp.bib()` function.
        * `pyp.pyptexfilename = &#39;a.pyptex&#39;`.
        * `pyp.auxfilename = &#39;a.aux&#39;`, useful in case bibtex is used.
        * `pyp.latex = &#34;pdflatex --file-line-error --synctex=1&#34;`.
          One may overwrite this in a.tex to choose a different latex engine, e.g.
          `pyp.latex = &#34;latex&#34;`.
        * `pyp.latexcommand` defaults to `False`, but the command-line version of `pyptex`
          uses something like.
          `r&#34;{latex} {pyptexfilename} &amp;&amp; (test ! -f {bibfilename} || bibtex {auxfilename})&#34;`
          The relevant substitutions are performed by `string.format` from `pyp.__dict__`.
        * `pyp.disable_cache = False`, set this to `True` if you want to disable the `a.pickle`
          cache. You shouldn&#39;t need to do this but if your Python code is nondeterministic
          or if tracking dependencies is too hard, disabling all caching will ensure
          that `a.pyptex` is correctly compiled into `a.pdf` and that a stale cache is
          never used.
        * `pyp.deps` is a dictionary of dependencies and timestamps.
        * `pyp.lc` counts lines while parsing.
        * `pyp.argv` stores the ``command-line arguments&#39;&#39; for template generation.
        * `pyp.exitcode` is the exit code of the `pyp.latexcommand`.
        * `pyp.gencount` is the counter for generated files (see `pyp.gen()`).
        * `pyp.fragments` is the list of Python fragments extracted from a.tex.
        * `pyp.outputs` is the matching outputs.
        * `pyp.compiled` is the string that is written to `a.pyptex`.
        * `pyp.autoshow` if True, each figure `fig` is automatically displayed (by `pyp.print`ing
        a suitable `includegraphics` command) at the end of each Python block. When a `fig` is thus
        displayed, `fig.drawn` is set to `True`. Figures that have already been `drawn` are not
        automatically displayed at the end of the Python block.
        &#34;&#34;&#34;
        print(f&#39;{texfilename}: pyptex compilation begins&#39;)
        self.__sympy_plot__ = sympy.plotting.plot(1, show=False).__class__
        self.__globals__ = {&#39;__builtins__&#39;: __builtins__, &#39;pyp&#39;: self }
        self.__frozen__ = self.__globals__.copy()
        self.__substarts__ = []
        self.__subends__ = []
        self.filename = stripext.sub(lambda m: m.group(1),texfilename)
        self.texfilename = texfilename
        matplotlib.use(&#34;module://pyptex&#34;)
        foo = self.filename+&#39;.tex&#39;
        self.pyptexfilename = foo if foo!=texfilename else f&#39;{self.filename}.pyptex&#39;
        self.cachefilename = f&#39;{self.filename}.pickle&#39;
        self.linemapfilename = f&#39;{self.filename}.linemap&#39;
        self.bibfilename = f&#39;{self.filename}.bib&#39;
        self.auxfilename = f&#39;{self.filename}.aux&#39;
        self.includegraphics = r&#39;\includegraphics[width=\textwidth]{%s}&#39;
        self.latex = &#39;pdflatex -file-line-error --synctex=1&#39;
        self.latexcommand = latexcommand
        self.disable_cache = False
        self.autoshow = True
        self.__show__ = matplotlib.pyplot.show
        self.deps = {}
        self.bibs = []
        self.lc = 0
        self.argv = [] if argv is None else argv
        self.exitcode = 0
        self.generateddir()
        self.dep(__file__)
        self.compile()
        print(f&#39;{texfilename}: pyptex compilation ends&#39;)
    def pp(self, Z):
        r&#34;&#34;&#34;Pretty-prints the template text string `Z`, using substitutions from the local
        scope that is `levels` calls up on the stack. The template character is @.

        For example, assume the caller has the value `x=3` in its local variables. Then,
        `pyp.pp(&#34;$x=@x$&#34;)` produces `$x=3$`.

        `pp` can also evaluate Python expressions in the template string, e.g.
        `pyp.pp(&#34;@{3+4}&#34;)` produces `7`.
        &#34;&#34;&#34;
        global ppparser,__stringtag__
        foo = inspect.currentframe().f_back
        def do_work(m):
            if m.start(1) &gt;= 0:
                return &#39;@&#39;
            for k in [2,3]:
                if m.start(k) &gt;= 0:
                    return self.mylatex(eval(compile(m.group(k),__stringtag__,mode=&#39;eval&#39;),
                        foo.f_globals, foo.f_locals))
            raise Exception(&#34;Tragic regular expression committed seppuku&#34;)

        return ppparser.sub(do_work, Z)

    def run(self, S, k):
        &#34;&#34;&#34;An internal function for executing Python code.&#34;&#34;&#34;
        print(f&#39;Executing Python code:\n{S}&#39;)
        glob_ = self.__globals__
        doeval = False
        self.__accum__ = []
        (ret,mode) = exec_and_catch(
            cmd=S,glob=glob_,loc=None,
            filename=self.texfilename,linecount=k
            )
        if mode==eval:
            self.__accum__.append(ret)
        if self.autoshow:
            self.showall()
        print(f&#39;Python result:\n{self.__accum__!s}&#39;)
        return self.__accum__

    def print(self, *argv):
        &#34;&#34;&#34;If `pyp` is an object of type `pyptex`, `pyp.print(X)` causes `X` to be converted
        to its latex representation and substituted into the `a.pyptex` output file.
        The conversion is given by `sympy.latex(X)`, except that `None` is converted
        to the empty string.

        Many values can be printed at once with the notation `pyp.print(X, Y, ...)`.&#34;&#34;&#34;
        for k in range(len(argv)):
            if isinstance(argv[k],matplotlib.pyplot.Figure):
                self.mylatex(argv[k])
        self.__accum__.extend(argv)

    def cite(self,b):
        r&#34;&#34;&#34;If `pyp` is an object of type `pyptex`, then `pyp.cite(X)` adds the relevant
        entry to the bibTeX file and returns the entry name. Example usage:

        `\cite{@{{{pyp.cite(r&#34;@article{seb97,title=Some title etc...}&#34;)}}}}`
        &#34;&#34;&#34;
        self.bibs.append(b)
        return bibentryname.match(b).group(1).strip()

    def process(self, S, runner, record_substitutions):
        &#34;&#34;&#34;An internal helper function for parsing the input file.&#34;&#34;&#34;
        ln = numpy.cumsum(numpy.array(numpy.array(list(S), dtype=&#39;U1&#39;) == &#39;\n&#39;, int))
        ln = numpy.insert(ln, 0, 0)

        def do_work(m):
            if m.start(1) &gt;= 0:
                return m.group(0)
            if m.start(2) &gt;= 0:
                return &#39;@&#39;
            for k in [6,9]:
                if m.start(k) &gt;= 0:
                    z = m.group(k)
                    z0 = m.start(k)
                    z1 = m.end(k)
                    o = m.group(k-1) or &#39;&#39;
                    break
            self.lc += ln[z1] - ln[z0] + 1
            ret = runner(z, ln[z0], o)
            if record_substitutions:
                self.__substarts__.append(ln[m.start(0)])
                self.__subends__.append(ln[m.end(0)])
            return ret

        return pypparser.sub(do_work, S)

    __pdoc__[&#39;mylatex&#39;] = False
    def mylatex(self, X):
        if X is None:
            return &#39;&#39;
        if isinstance(X, str):
            return X
        if isinstance(X,pyptexNameSpace):
            return str(X)
        if isinstance(X,matplotlib.pyplot.Figure):
            self.__setupfig__(X)
            print(X.__IG__)
            X.canvas.print_figure(X.__FIGNAME__)
            X.drawn = True
            return X.__IG__
        if isinstance(X,self.__sympy_plot__):
            return &#34;&#34;
        if isinstance(X,matplotlib.artist.Artist):
            return &#34;&#34;
        if isinstance(X,list) and isinstance(X[0],matplotlib.artist.Artist):
            return &#34;&#34;
        return sympy.latex(X)

    def compile(self):
        &#34;&#34;&#34;An internal function for compiling the input file.&#34;&#34;&#34;
        with open(self.texfilename, &#39;rt&#39;) as file:
            text = file.read()
        try:
            with open(self.cachefilename, &#39;rb&#39;) as file:
                cache = pickle.load(file)
        except Exception:
            cache = {}
        defaults = {
            &#39;fragments&#39;: [],
            &#39;outputs&#39;: [],
            &#39;deps&#39;: {},
            &#39;argv&#39;: [],
            &#39;disable_cache&#39;: True,
        }
        for k, v in defaults.items():
            if k not in cache:
                cache[k] = v
        self.fragments = []

        def scanner(C, k, o):
            self.fragments.append(C)
            assert o in [&#39;&#39;,&#39;verbatim&#39;],&#34;Invalid option: &#34;+o
            return &#39;&#39;

        self.process(text, runner=scanner, record_substitutions=True)
        print(f&#39;Found {self.lc!s} lines of Python.&#39;)
        saveddeps = self.deps
        self.deps = {}
        for k in cache[&#39;deps&#39;]:
            self.dep(k)
        self.resolvedeps()
        cached = True
        if cache[&#39;disable_cache&#39;]:
            print(&#39;disable_cache=True&#39;)
            cached = False
        elif cache[&#39;argv&#39;] != self.argv:
            print(&#39;argv differs&#39;, self.argv, cache[&#39;argv&#39;])
            cached = False
        elif cache[&#39;fragments&#39;] != self.fragments:
            F1 = dict(enumerate(cache[&#39;fragments&#39;]))
            F2 = dict(enumerate(self.fragments))
            k = dictdiff(F1, F2)[0]
            print(&#39;Fragment #&#39;, k,
                  &#39;\nCached version:\n&#39;, F1[k] if k in F1 else None,
                  &#39;\nLive version:\n&#39;, F2[k] if k in F2 else None)
            cached = False
        elif self.deps != cache[&#39;deps&#39;]:
            F1 = cache[&#39;deps&#39;]
            F2 = self.deps
            k = dictdiff(F1, F2)[0]
            print(&#39;Dependency mismatch&#39;, k,
                  &#39;\nCached version:\n&#39;, F1[k] if k in F1 else None,
                  &#39;\nLive version:\n&#39;, F2[k] if k in F2 else None)
            cached = False
        if cached:
            print(&#39;Using cached Python outputs&#39;)
            for k, v in cache.items():
                self.__dict__[k] = v
            self.subcount = -1

            def subber(C, k, o):
                self.subcount += 1
                if(o==&#39;&#39;):
                    return self.outputs[self.subcount]
                if(o==&#39;verbatim&#39;):
                    return C

            self.compiled = self.process(text, runner=subber, record_substitutions=False)
        else:
            print(&#39;Cache is invalidated.&#39;)
            self.deps = saveddeps
            self.outputs = []

            def appender(C, k, o):
                result = self.run(C, k)
                self.outputs.append(&#39;&#39;.join(map(self.mylatex, result)))
                if(o==&#39;&#39;):
                    return self.outputs[-1]
                if(o==&#39;verbatim&#39;):
                    return C

            self.compiled = self.process(text, runner=appender, record_substitutions=False)
        sys.stdout.flush()
        if self.pyptexfilename:
            print(f&#39;Saving to file: {self.pyptexfilename}&#39;)
            with open(self.pyptexfilename, &#39;wt&#39;) as file:
                file.write(self.compiled)
        self.resolvedeps()
        print(f&#39;Dependencies are:\n{self.deps!s}&#39;)
        numlines = len(text.split(&#39;\n&#39;))
        linemaps = []
        prevline = 0
        for k in range(len(self.outputs)):
            linemaps.append(list(range(prevline+1,self.__substarts__[k]+1)))
            count = len(self.outputs[k].split(&#39;\n&#39;))
            linemaps.append([self.__substarts__[k]]*(count-1))
            prevline = self.__subends__[k]
        linemaps.append(list(range(prevline+1,numlines+1)))
        self.linemap = [str(x) for sublist in linemaps for x in sublist]
        print(&#39;Saving cache file&#39;, self.cachefilename)
        with open(self.cachefilename, &#39;wb&#39;) as file:
            cache = {}
            for k, v in self.__dict__.items():
                if k[0:2] == &#39;__&#39; and k[-2:] == &#39;__&#39;:
                    pass
                elif callable(v):
                    pass
                else:
                    cache[k] = v
            pickle.dump(cache, file)
        if self.latexcommand:
            cmd = self.latexcommand.format(**self.__dict__)
            print(f&#39;Running Latex command:\n{cmd}&#39;)
            self.exitcode = os.system(cmd)

    def bib(self, bib=&#34;&#34;):
        &#34;&#34;&#34;A helper function for creating a `.bib` file. If `pyp=pyptex(&#39;a.tex&#39;)`,
        then `pyp.bib(&#39;&#39;&#39;@book{knuth1984texbook, title={The {TEXbook}},
        author={Knuth, Donald Ervin and Bibby, Duane}}&#39;&#39;&#39;)` creates a file
        `a.bib` with the given text. This is just a convenience function
        that makes it easier to incorporate the bibtex file straight into the
        `a.tex` source. In `a.tex`, the typical way of using it is:
        `\\bibliography{@{{{pyp.bib(&#34;...&#34;)}}}}`.
        &#34;&#34;&#34;
        self.bibs.append(bib)
        with self.open(self.bibfilename, &#39;wt&#39;) as file:
            file.write(&#34;\n&#34;.join(self.bibs))
        return self.filename

    def dep(self, filename):
        &#34;&#34;&#34;If `pyp=pyptex(&#39;a.tex&#39;)`, then `pyp.dep(filename)` declares that the Python code
        in `a.tex` depends on the file designated by `filename`. When the object
        `pyptex(&#39;a.tex&#39;)` is constructed, the file `a.pickle` will be loaded (if it exists).
        `a.pickle` is a cache of the results of the Python calculations in `a.tex`.
        If the cache is deemed valid, the `pyptex` constructor does not rerun all
        the Python fragments in `a.tex` but instead uses the previously cached outputs.

        The cache is invalidated under the following scenarios:
        1. The new Python fragments in `a.tex` are not identical to the cached fragments.
        2. The &#34;last modification&#34; timestamp on dependencies is not the same as in the cache.
        3. `pyp.disable_cache==True`.

        The list of dependencies defaults to only the `pyptex` executable. Additional
        dependencies can be manually declared via `pyp.dep(filename)`.

        For convenience, `pyp.dep(filename)` returns filename.
        &#34;&#34;&#34;
        self.deps[filename] = &#39;&#39;
        return filename

    def resolvedeps(self):
        &#34;&#34;&#34;An internal function that actually computes the datestamps of dependencies.&#34;&#34;&#34;
        for k in self.deps:
            try:
                ds = format_my_nanos(os.stat(k).st_mtime_ns)
            except Exception:
                ds = &#39;&#39;
            self.deps[k] = ds

    def input(self, filename, argv=False):
        r&#34;&#34;&#34;If `pyp = pyptex(&#39;a.tex&#39;)` then
        `pyp.input(&#39;b.tex&#39;)`
        returns the string `\input{&#34;b.pyptex&#34;}`. The common way of using this is to
        put `@{pyp.input(&#39;b.tex&#39;)}` somewhere in `a.tex`.
        The function `pyp.input(&#39;b.tex&#39;)` internally calls the constructor
        `pyptex(&#39;b.tex&#39;)` so that `b.pyptex` is compiled from `b.tex`.

        Note that the two files `a.tex` and `b.tex` are &#34;semantically isolated&#34;. All
        calculations, variables and functions defined in `a.tex` live in a global scope
        that is private to `a.tex`, much like each Python module has a private global
        scope. In a similar fashion, `b.tex` has its own private global scope.
        The global `pyp` objects in `a.tex` and `b.tex` are also different instances
        of the `pyptex` class. This is similar to the notion of &#34;compilation units&#34; in
        the C programming language.

        From `a.tex`, one can retrieve global variables of `b.tex` as follows. If
        `foo = pyp.input(&#39;b.tex&#39;)`, and if `b.tex` defines a global variable `x`,
        then it can be retrieved by `foo.x`. The `foo` variable is an instance of a
        `pyptexNameSpace` that contains the global scope of `b.tex`. This type has a
        custom string representation, so that `str(foo)` or `@{foo}` is
        `&#39;\input{b.pyptex}&#39;`.

        If one wishes to pass some parameters from `a.tex` to `b.tex`, one may use
        the notation `pyp.input(&#39;b.tex&#39;, argv)`, which will initialize the global
        `pyp` object of `b.tex` so that it contains the field `pyp.argv=argv`.
        &#34;&#34;&#34;
        ret = pyptex(filename, argv or self.argv, False)
        ret2 = pyptexNameSpace(ret.__globals__)
        return ret2

    def open(self, filename, *argv, **kwargs):
        &#34;&#34;&#34;If pyp = pyptex(&#39;a.tex&#39;) then pyp.open(filename, ...) is a wrapper for
        the builtin function open(filename, ...) that further adds filename to
        the list of dependencies via pyp.dep(filename).
        &#34;&#34;&#34;
        self.dep(filename)
        return open(filename, *argv, **kwargs)


class MyWriter(streamcapture.Writer):
    def __init__(self,stream):
        super(MyWriter, self).__init__(stream)
        self.last = b&#34;&#34;
        self.matcher = re.compile(r&#39;([^:]*):([0-9]+): LaTeX Error&#39;)
    def write_from(self,data,cap):
        foo = data.split(b&#34;\n&#34;)
        n = len(foo)
        for k in range(n):
            bar = b&#34;&#34; if k&gt;0 else self.last
            baz = self.matcher.match((bar+foo[k]).decode())
            if baz:
                try:
                    pyptexfile = baz.group(1)
                    basename = stripext.sub(lambda m: m.group(1),pyptexfile)
                    picklefile = basename+&#39;.pickle&#39;
                    with open(picklefile, &#39;rb&#39;) as file:
                        cache = pickle.load(file)
                    texfile = cache[&#39;texfilename&#39;]
                    pyptexlinenumber = int(baz.group(2))
                    texlinenumber = cache[&#39;linemap&#39;][pyptexlinenumber-1]
                    foo[k] += (f&#34;\n{texfile}:{texlinenumber}: PypTeX source file&#34;).encode()
                    data = b&#34;\n&#34;.join(foo)
                except Exception:
                    pass
        if n&lt;2:
            self.last = b&#34;&#34;
        self.last += foo[n-1]
        self._write(data)
        os.write(cap.dup_fd,data)


def pyptexmain(argv: list = None):
    &#34;&#34;&#34;This function parses an input file a.tex to produce a.pyptex and a.pdf, by
    doing pyp = pyptex(&#39;a.tex&#39;, ...) object. The filename a.tex must be in argv[1];
    if argv is not provided, it is taken from sys.argv.
    The default pyp.latexcommand invokes pdflatex and, if a.bib is present, also bibtex.
    If an exception occurs, pdb is automatically invoked in postmortem mode.
    If &#34;--pdb=no&#34; is in argv, it is removed from argv and automatic pdb postmortem is disabled.
    If &#34;--pdb=yes&#34; is in argv, automatic pdb postmortem is enabled. This is the default.
    &#34;&#34;&#34;
    argv = argv or sys.argv
    dopdb = True
    with suppress(Exception):
        argv.remove(&#39;--pdb=no&#39;)
        dopdb = False
    with suppress(Exception):
        argv.remove(&#39;--pdb=yes&#39;)
        dopdb = True
    if len(argv) &lt; 2:
        print(&#39;Usage: pyptex &lt;filename.tex&gt; ...&#39;)
        sys.exit(1)
    writer = MyWriter(open(f&#39;{os.path.splitext(argv[1])[0]}.pyplog&#39;,&#39;wb&#39;))
    with streamcapture.StreamCapture(sys.stdout,writer,echo=False), streamcapture.StreamCapture(sys.stderr,writer,echo=False):
        try:
            pyp = pyptex(argv[1], argv[2:],
                latexcommand=r&#39;{latex} {pyptexfilename} &amp;&amp; (test ! -f {bibfilename} || bibtex {auxfilename})&#39;,
                )
        except Exception as e:
            import pdb
#            e = filter_exception(e)
            print(__format_exception__(e))
#            print(&#39;\n&#39;.join(traceback.TracebackException(exc_type=type(foo), exc_value=foo, exc_traceback=foo.__traceback__).format()))
            if e.__traceback__ is not None and dopdb:
                print(&#39;A Python error has occurred. Launching the debugger pdb.\n&#39;
                      &#34;Type &#39;help&#39; for a list of commands, and &#39;quit&#39; when done.&#34;)
                pdb.post_mortem(e.__traceback__)
            sys.exit(1)
    return pyp.exitcode</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pyptex.pyptexmain"><code class="name flex">
<span>def <span class="ident">pyptexmain</span></span>(<span>argv: list = None)</span>
</code></dt>
<dd>
<div class="desc"><p>This function parses an input file a.tex to produce a.pyptex and a.pdf, by
doing pyp = pyptex('a.tex', &hellip;) object. The filename a.tex must be in argv[1];
if argv is not provided, it is taken from sys.argv.
The default pyp.latexcommand invokes pdflatex and, if a.bib is present, also bibtex.
If an exception occurs, pdb is automatically invoked in postmortem mode.
If "&ndash;pdb=no" is in argv, it is removed from argv and automatic pdb postmortem is disabled.
If "&ndash;pdb=yes" is in argv, automatic pdb postmortem is enabled. This is the default.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pyptexmain(argv: list = None):
    &#34;&#34;&#34;This function parses an input file a.tex to produce a.pyptex and a.pdf, by
    doing pyp = pyptex(&#39;a.tex&#39;, ...) object. The filename a.tex must be in argv[1];
    if argv is not provided, it is taken from sys.argv.
    The default pyp.latexcommand invokes pdflatex and, if a.bib is present, also bibtex.
    If an exception occurs, pdb is automatically invoked in postmortem mode.
    If &#34;--pdb=no&#34; is in argv, it is removed from argv and automatic pdb postmortem is disabled.
    If &#34;--pdb=yes&#34; is in argv, automatic pdb postmortem is enabled. This is the default.
    &#34;&#34;&#34;
    argv = argv or sys.argv
    dopdb = True
    with suppress(Exception):
        argv.remove(&#39;--pdb=no&#39;)
        dopdb = False
    with suppress(Exception):
        argv.remove(&#39;--pdb=yes&#39;)
        dopdb = True
    if len(argv) &lt; 2:
        print(&#39;Usage: pyptex &lt;filename.tex&gt; ...&#39;)
        sys.exit(1)
    writer = MyWriter(open(f&#39;{os.path.splitext(argv[1])[0]}.pyplog&#39;,&#39;wb&#39;))
    with streamcapture.StreamCapture(sys.stdout,writer,echo=False), streamcapture.StreamCapture(sys.stderr,writer,echo=False):
        try:
            pyp = pyptex(argv[1], argv[2:],
                latexcommand=r&#39;{latex} {pyptexfilename} &amp;&amp; (test ! -f {bibfilename} || bibtex {auxfilename})&#39;,
                )
        except Exception as e:
            import pdb
#            e = filter_exception(e)
            print(__format_exception__(e))
#            print(&#39;\n&#39;.join(traceback.TracebackException(exc_type=type(foo), exc_value=foo, exc_traceback=foo.__traceback__).format()))
            if e.__traceback__ is not None and dopdb:
                print(&#39;A Python error has occurred. Launching the debugger pdb.\n&#39;
                      &#34;Type &#39;help&#39; for a list of commands, and &#39;quit&#39; when done.&#34;)
                pdb.post_mortem(e.__traceback__)
            sys.exit(1)
    return pyp.exitcode</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyptex.MyWriter"><code class="flex name class">
<span>class <span class="ident">MyWriter</span></span>
<span>(</span><span>stream)</span>
</code></dt>
<dd>
<div class="desc"><p><code>Writer</code> constructor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MyWriter(streamcapture.Writer):
    def __init__(self,stream):
        super(MyWriter, self).__init__(stream)
        self.last = b&#34;&#34;
        self.matcher = re.compile(r&#39;([^:]*):([0-9]+): LaTeX Error&#39;)
    def write_from(self,data,cap):
        foo = data.split(b&#34;\n&#34;)
        n = len(foo)
        for k in range(n):
            bar = b&#34;&#34; if k&gt;0 else self.last
            baz = self.matcher.match((bar+foo[k]).decode())
            if baz:
                try:
                    pyptexfile = baz.group(1)
                    basename = stripext.sub(lambda m: m.group(1),pyptexfile)
                    picklefile = basename+&#39;.pickle&#39;
                    with open(picklefile, &#39;rb&#39;) as file:
                        cache = pickle.load(file)
                    texfile = cache[&#39;texfilename&#39;]
                    pyptexlinenumber = int(baz.group(2))
                    texlinenumber = cache[&#39;linemap&#39;][pyptexlinenumber-1]
                    foo[k] += (f&#34;\n{texfile}:{texlinenumber}: PypTeX source file&#34;).encode()
                    data = b&#34;\n&#34;.join(foo)
                except Exception:
                    pass
        if n&lt;2:
            self.last = b&#34;&#34;
        self.last += foo[n-1]
        self._write(data)
        os.write(cap.dup_fd,data)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>streamcapture.Writer</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyptex.MyWriter.write_from"><code class="name flex">
<span>def <span class="ident">write_from</span></span>(<span>self, data, cap)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_from(self,data,cap):
    foo = data.split(b&#34;\n&#34;)
    n = len(foo)
    for k in range(n):
        bar = b&#34;&#34; if k&gt;0 else self.last
        baz = self.matcher.match((bar+foo[k]).decode())
        if baz:
            try:
                pyptexfile = baz.group(1)
                basename = stripext.sub(lambda m: m.group(1),pyptexfile)
                picklefile = basename+&#39;.pickle&#39;
                with open(picklefile, &#39;rb&#39;) as file:
                    cache = pickle.load(file)
                texfile = cache[&#39;texfilename&#39;]
                pyptexlinenumber = int(baz.group(2))
                texlinenumber = cache[&#39;linemap&#39;][pyptexlinenumber-1]
                foo[k] += (f&#34;\n{texfile}:{texlinenumber}: PypTeX source file&#34;).encode()
                data = b&#34;\n&#34;.join(foo)
            except Exception:
                pass
    if n&lt;2:
        self.last = b&#34;&#34;
    self.last += foo[n-1]
    self._write(data)
    os.write(cap.dup_fd,data)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyptex.pyptex"><code class="flex name class">
<span>class <span class="ident">pyptex</span></span>
<span>(</span><span>texfilename, argv=None, latexcommand=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Class <code><a title="pyptex.pyptex" href="#pyptex.pyptex">pyptex</a></code> is used to parse an input (templated) <code>a.tex</code> file
and produce an output <code>a.pyptex</code> file, and can be used as follows:
<code>pyp = pyptex('a.tex')</code>
The constructor reads <code>a.tex</code>, executes Python fragments and performs relevant
substitutions, writing <code>a.pyptex</code> to disk. The contents of <code>a.pyptex</code> are also
available as <code>pyp.compiled</code>.</p>
<p><code>pyp = pyptex('a.tex')</code> reads in the LaTeX file a.tex and locates all
Python code fragments contained inside. These Python code fragments are
executed and their outputs are substituted to produce the <code>a.pyptex</code> output file.</p>
<p><code>pyp = pyptex('a.tex', argv)</code> passes "command-line arguments". The pyptex
command-line passes <code>sys.argv[2:]</code> for this parameter. If omitted, <code>argv</code>
defaults to <code>[]</code>. If using PypTeX as an templating engine to generate
multiple documents from a single source <code>a.tex</code> file, one should use
the <code>argv</code> parameter to pass in the various side-parameters needed to generate
each document. For example, <code>a.tex</code> might have the line "Dear @{pyp.argv[0]}""
One could produce a letter to John by doing <code>pyp = pyptex('a.tex', ['John'])</code>.</p>
<p><code>pyp = pyptex('a.tex', argv, latexcommand)</code> further executes a specific shell
command once <code>a.pyptex</code> has been written to disk (e.g. <code>pdflatex {pytexfilename}</code>).
The default value of <code>latexcommand</code> is <code>False</code>, in which case no shell command
is executed.</p>
<p>Some salient fields of the <code>pyp=pyptex('a.tex')</code> class are:</p>
<ul>
<li><code>pyp.filename = 'a'</code> (so <code>a.tex</code>, with the extension stripped).</li>
<li><code>pyp.texfilename = 'a.tex'</code>.</li>
<li><code>pyp.cachefilename = 'a.pickle'</code>.</li>
<li><code>pyp.bibfilename = 'a.bib'</code>, used by the <code>pyp.bib()</code> function.</li>
<li><code>pyp.pyptexfilename = 'a.pyptex'</code>.</li>
<li><code>pyp.auxfilename = 'a.aux'</code>, useful in case bibtex is used.</li>
<li><code>pyp.latex = "pdflatex --file-line-error --synctex=1"</code>.
One may overwrite this in a.tex to choose a different latex engine, e.g.
<code>pyp.latex = "latex"</code>.</li>
<li><code>pyp.latexcommand</code> defaults to <code>False</code>, but the command-line version of <code><a title="pyptex.pyptex" href="#pyptex.pyptex">pyptex</a></code>
uses something like.
<code>r"{latex} {pyptexfilename} &amp;&amp; (test ! -f {bibfilename} || bibtex {auxfilename})"</code>
The relevant substitutions are performed by <code>string.format</code> from <code>pyp.__dict__</code>.</li>
<li><code>pyp.disable_cache = False</code>, set this to <code>True</code> if you want to disable the <code>a.pickle</code>
cache. You shouldn't need to do this but if your Python code is nondeterministic
or if tracking dependencies is too hard, disabling all caching will ensure
that <code>a.pyptex</code> is correctly compiled into <code>a.pdf</code> and that a stale cache is
never used.</li>
<li><code>pyp.deps</code> is a dictionary of dependencies and timestamps.</li>
<li><code>pyp.lc</code> counts lines while parsing.</li>
<li><code>pyp.argv</code> stores the ``command-line arguments'' for template generation.</li>
<li><code>pyp.exitcode</code> is the exit code of the <code>pyp.latexcommand</code>.</li>
<li><code>pyp.gencount</code> is the counter for generated files (see <code>pyp.gen()</code>).</li>
<li><code>pyp.fragments</code> is the list of Python fragments extracted from a.tex.</li>
<li><code>pyp.outputs</code> is the matching outputs.</li>
<li><code>pyp.compiled</code> is the string that is written to <code>a.pyptex</code>.</li>
<li><code>pyp.autoshow</code> if True, each figure <code>fig</code> is automatically displayed (by <code>pyp.print</code>ing
a suitable <code>includegraphics</code> command) at the end of each Python block. When a <code>fig</code> is thus
displayed, <code>fig.drawn</code> is set to <code>True</code>. Figures that have already been <code>drawn</code> are not
automatically displayed at the end of the Python block.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class pyptex:
    r&#34;&#34;&#34;Class `pyptex.pyptex` is used to parse an input (templated) `a.tex` file
    and produce an output `a.pyptex` file, and can be used as follows:
        `pyp = pyptex(&#39;a.tex&#39;)`
    The constructor reads `a.tex`, executes Python fragments and performs relevant
    substitutions, writing `a.pyptex` to disk. The contents of `a.pyptex` are also
    available as `pyp.compiled`.
    &#34;&#34;&#34;

    def genname(self, pattern: str = &#39;fig{gencount}.eps&#39;):
        r&#34;&#34;&#34;Generate a filename

        To produce an automatically generated filename, use the statement
        `pyp.genname()`, where `pyp` is an object of type `pyptex`, for parsing a
        given file `a.tex`. By default, this will generate the name
        `&#39;a-generated/fig{gencount}.eps&#39;`.
        The subdirectory can be overridden by overwriting `pyp.gendir`,
        and `gencount` denotes `pyp.gencount`. Any desired pattern can be used,
        for example:
            `name = pyp.genname(&#39;hello-{gencount}-{thing}.txt&#39;)`
        will return something like `&#39;a-generated/hello-X-Y.txt&#39;`, where
        `X` is `pyp.gencount` and `Y` is `pyp.thing`.

        `pyp.genname()` does not actually create the file. `pyp.genname()` increments
        `pyp.gencount` every time it is called.
        &#34;&#34;&#34;
        self.gencount += 1
        return f&#39;{self.gendir}/{pattern.format(**self.__dict__)}&#39;

    def __setupfig__(self, fig):
        if not hasattr(fig,&#39;__FIGNAME__&#39;):
            figname = self.genname()
            Path(figname).touch()
            self.dep(figname)
            fig.__FIGNAME__ = figname
        if not hasattr(fig,&#39;__IG__&#39;):
            fig.__IG__ = (self.includegraphics%figname)
        if not hasattr(fig,&#39;drawn&#39;):
            fig.drawn = False
        return fig.__IG__
    def showall(self):
        for num, figmanager in enumerate(Gcf.get_all_fig_managers()):
            fig = figmanager.canvas.figure
            self.__setupfig__(fig)
            if fig.drawn:
                pass
            else:
                self.print(fig)

    def generateddir(self):
        &#34;&#34;&#34;This is an internal function that creates the generated directory.&#34;&#34;&#34;
        self.gendir = f&#39;{self.filename}-generated&#39;
        if not os.path.exists(self.gendir):
            os.makedirs(self.gendir)
        self.gencount = 0
    def freeze(self):
        &#34;&#34;&#34;&#39;Freezes&#39; the global scope of the caller by performing a shallow copy and copying it to 
        `pyp.__frozen__`

        See also `pyptex.clear()`&#34;&#34;&#34;
        self.__frozen__ = inspect.stack()[1][0].f_globals.copy()
    def clear(self):
        &#34;&#34;&#34;Clears all global variable.

        pyptex.clear() clears all the global variables of the caller. Example usage:
        ```python
        a = 1
        print(a)      # this prints 1
        pyp.clear()
        print(a)      # this raises an exception because
                      # a is now undefined.
        ```
        
        The global scope is restored from the dictionary `pyp.__frozen__`, which initially only contains
        the pyp object and the `__builtins__` module. One can add more items to the `__frozen__` dict, e.g.
        by importing some standard module. For example,

        ```python
        my_variable = 78
        import sys
        pyp.freeze()     # This freezes my_variable and sys.
        foo = 1          # Now foo is defined...
        pyp.clear()
        # ...Now foo is undefined, but my_variable is still 78,
        # and the sys module is still available.
        ```

        Note that `pyp.freeze()` performs a shallow copy, so:
        ```python
        a = [1,2,3]
        pyp.freeze()  # a = [1,2,3] is now in the frozen scope.
        a[1] = 7      # Now a = [1,7,3] in the global scope.
        pyp.clear()
        # Still a = [1,7,3] because the scope copy was shallow.
        ```
        &#34;&#34;&#34;
        foo = self.__frozen__
        bar = inspect.stack()[1][0].f_globals
        for k,v in foo.items():
            bar[k] = v
        kk = list(bar.keys())
        for k in kk:
            if k not in foo:
                del bar[k]

    def __init__(self, texfilename, argv=None, latexcommand=False):
        r&#34;&#34;&#34;`pyp = pyptex(&#39;a.tex&#39;)` reads in the LaTeX file a.tex and locates all
        Python code fragments contained inside. These Python code fragments are
        executed and their outputs are substituted to produce the `a.pyptex` output file.

        `pyp = pyptex(&#39;a.tex&#39;, argv)` passes &#34;command-line arguments&#34;. The pyptex
        command-line passes `sys.argv[2:]` for this parameter. If omitted, `argv`
        defaults to `[]`. If using PypTeX as an templating engine to generate
        multiple documents from a single source `a.tex` file, one should use
        the `argv` parameter to pass in the various side-parameters needed to generate
        each document. For example, `a.tex` might have the line &#34;Dear @{pyp.argv[0]}&#34;&#34;
        One could produce a letter to John by doing `pyp = pyptex(&#39;a.tex&#39;, [&#39;John&#39;])`.

        `pyp = pyptex(&#39;a.tex&#39;, argv, latexcommand)` further executes a specific shell
        command once `a.pyptex` has been written to disk (e.g. `pdflatex {pytexfilename}`).
        The default value of `latexcommand` is `False`, in which case no shell command
        is executed.

        Some salient fields of the `pyp=pyptex(&#39;a.tex&#39;)` class are:

        * `pyp.filename = &#39;a&#39;` (so `a.tex`, with the extension stripped).
        * `pyp.texfilename = &#39;a.tex&#39;`.
        * `pyp.cachefilename = &#39;a.pickle&#39;`.
        * `pyp.bibfilename = &#39;a.bib&#39;`, used by the `pyp.bib()` function.
        * `pyp.pyptexfilename = &#39;a.pyptex&#39;`.
        * `pyp.auxfilename = &#39;a.aux&#39;`, useful in case bibtex is used.
        * `pyp.latex = &#34;pdflatex --file-line-error --synctex=1&#34;`.
          One may overwrite this in a.tex to choose a different latex engine, e.g.
          `pyp.latex = &#34;latex&#34;`.
        * `pyp.latexcommand` defaults to `False`, but the command-line version of `pyptex`
          uses something like.
          `r&#34;{latex} {pyptexfilename} &amp;&amp; (test ! -f {bibfilename} || bibtex {auxfilename})&#34;`
          The relevant substitutions are performed by `string.format` from `pyp.__dict__`.
        * `pyp.disable_cache = False`, set this to `True` if you want to disable the `a.pickle`
          cache. You shouldn&#39;t need to do this but if your Python code is nondeterministic
          or if tracking dependencies is too hard, disabling all caching will ensure
          that `a.pyptex` is correctly compiled into `a.pdf` and that a stale cache is
          never used.
        * `pyp.deps` is a dictionary of dependencies and timestamps.
        * `pyp.lc` counts lines while parsing.
        * `pyp.argv` stores the ``command-line arguments&#39;&#39; for template generation.
        * `pyp.exitcode` is the exit code of the `pyp.latexcommand`.
        * `pyp.gencount` is the counter for generated files (see `pyp.gen()`).
        * `pyp.fragments` is the list of Python fragments extracted from a.tex.
        * `pyp.outputs` is the matching outputs.
        * `pyp.compiled` is the string that is written to `a.pyptex`.
        * `pyp.autoshow` if True, each figure `fig` is automatically displayed (by `pyp.print`ing
        a suitable `includegraphics` command) at the end of each Python block. When a `fig` is thus
        displayed, `fig.drawn` is set to `True`. Figures that have already been `drawn` are not
        automatically displayed at the end of the Python block.
        &#34;&#34;&#34;
        print(f&#39;{texfilename}: pyptex compilation begins&#39;)
        self.__sympy_plot__ = sympy.plotting.plot(1, show=False).__class__
        self.__globals__ = {&#39;__builtins__&#39;: __builtins__, &#39;pyp&#39;: self }
        self.__frozen__ = self.__globals__.copy()
        self.__substarts__ = []
        self.__subends__ = []
        self.filename = stripext.sub(lambda m: m.group(1),texfilename)
        self.texfilename = texfilename
        matplotlib.use(&#34;module://pyptex&#34;)
        foo = self.filename+&#39;.tex&#39;
        self.pyptexfilename = foo if foo!=texfilename else f&#39;{self.filename}.pyptex&#39;
        self.cachefilename = f&#39;{self.filename}.pickle&#39;
        self.linemapfilename = f&#39;{self.filename}.linemap&#39;
        self.bibfilename = f&#39;{self.filename}.bib&#39;
        self.auxfilename = f&#39;{self.filename}.aux&#39;
        self.includegraphics = r&#39;\includegraphics[width=\textwidth]{%s}&#39;
        self.latex = &#39;pdflatex -file-line-error --synctex=1&#39;
        self.latexcommand = latexcommand
        self.disable_cache = False
        self.autoshow = True
        self.__show__ = matplotlib.pyplot.show
        self.deps = {}
        self.bibs = []
        self.lc = 0
        self.argv = [] if argv is None else argv
        self.exitcode = 0
        self.generateddir()
        self.dep(__file__)
        self.compile()
        print(f&#39;{texfilename}: pyptex compilation ends&#39;)
    def pp(self, Z):
        r&#34;&#34;&#34;Pretty-prints the template text string `Z`, using substitutions from the local
        scope that is `levels` calls up on the stack. The template character is @.

        For example, assume the caller has the value `x=3` in its local variables. Then,
        `pyp.pp(&#34;$x=@x$&#34;)` produces `$x=3$`.

        `pp` can also evaluate Python expressions in the template string, e.g.
        `pyp.pp(&#34;@{3+4}&#34;)` produces `7`.
        &#34;&#34;&#34;
        global ppparser,__stringtag__
        foo = inspect.currentframe().f_back
        def do_work(m):
            if m.start(1) &gt;= 0:
                return &#39;@&#39;
            for k in [2,3]:
                if m.start(k) &gt;= 0:
                    return self.mylatex(eval(compile(m.group(k),__stringtag__,mode=&#39;eval&#39;),
                        foo.f_globals, foo.f_locals))
            raise Exception(&#34;Tragic regular expression committed seppuku&#34;)

        return ppparser.sub(do_work, Z)

    def run(self, S, k):
        &#34;&#34;&#34;An internal function for executing Python code.&#34;&#34;&#34;
        print(f&#39;Executing Python code:\n{S}&#39;)
        glob_ = self.__globals__
        doeval = False
        self.__accum__ = []
        (ret,mode) = exec_and_catch(
            cmd=S,glob=glob_,loc=None,
            filename=self.texfilename,linecount=k
            )
        if mode==eval:
            self.__accum__.append(ret)
        if self.autoshow:
            self.showall()
        print(f&#39;Python result:\n{self.__accum__!s}&#39;)
        return self.__accum__

    def print(self, *argv):
        &#34;&#34;&#34;If `pyp` is an object of type `pyptex`, `pyp.print(X)` causes `X` to be converted
        to its latex representation and substituted into the `a.pyptex` output file.
        The conversion is given by `sympy.latex(X)`, except that `None` is converted
        to the empty string.

        Many values can be printed at once with the notation `pyp.print(X, Y, ...)`.&#34;&#34;&#34;
        for k in range(len(argv)):
            if isinstance(argv[k],matplotlib.pyplot.Figure):
                self.mylatex(argv[k])
        self.__accum__.extend(argv)

    def cite(self,b):
        r&#34;&#34;&#34;If `pyp` is an object of type `pyptex`, then `pyp.cite(X)` adds the relevant
        entry to the bibTeX file and returns the entry name. Example usage:

        `\cite{@{{{pyp.cite(r&#34;@article{seb97,title=Some title etc...}&#34;)}}}}`
        &#34;&#34;&#34;
        self.bibs.append(b)
        return bibentryname.match(b).group(1).strip()

    def process(self, S, runner, record_substitutions):
        &#34;&#34;&#34;An internal helper function for parsing the input file.&#34;&#34;&#34;
        ln = numpy.cumsum(numpy.array(numpy.array(list(S), dtype=&#39;U1&#39;) == &#39;\n&#39;, int))
        ln = numpy.insert(ln, 0, 0)

        def do_work(m):
            if m.start(1) &gt;= 0:
                return m.group(0)
            if m.start(2) &gt;= 0:
                return &#39;@&#39;
            for k in [6,9]:
                if m.start(k) &gt;= 0:
                    z = m.group(k)
                    z0 = m.start(k)
                    z1 = m.end(k)
                    o = m.group(k-1) or &#39;&#39;
                    break
            self.lc += ln[z1] - ln[z0] + 1
            ret = runner(z, ln[z0], o)
            if record_substitutions:
                self.__substarts__.append(ln[m.start(0)])
                self.__subends__.append(ln[m.end(0)])
            return ret

        return pypparser.sub(do_work, S)

    __pdoc__[&#39;mylatex&#39;] = False
    def mylatex(self, X):
        if X is None:
            return &#39;&#39;
        if isinstance(X, str):
            return X
        if isinstance(X,pyptexNameSpace):
            return str(X)
        if isinstance(X,matplotlib.pyplot.Figure):
            self.__setupfig__(X)
            print(X.__IG__)
            X.canvas.print_figure(X.__FIGNAME__)
            X.drawn = True
            return X.__IG__
        if isinstance(X,self.__sympy_plot__):
            return &#34;&#34;
        if isinstance(X,matplotlib.artist.Artist):
            return &#34;&#34;
        if isinstance(X,list) and isinstance(X[0],matplotlib.artist.Artist):
            return &#34;&#34;
        return sympy.latex(X)

    def compile(self):
        &#34;&#34;&#34;An internal function for compiling the input file.&#34;&#34;&#34;
        with open(self.texfilename, &#39;rt&#39;) as file:
            text = file.read()
        try:
            with open(self.cachefilename, &#39;rb&#39;) as file:
                cache = pickle.load(file)
        except Exception:
            cache = {}
        defaults = {
            &#39;fragments&#39;: [],
            &#39;outputs&#39;: [],
            &#39;deps&#39;: {},
            &#39;argv&#39;: [],
            &#39;disable_cache&#39;: True,
        }
        for k, v in defaults.items():
            if k not in cache:
                cache[k] = v
        self.fragments = []

        def scanner(C, k, o):
            self.fragments.append(C)
            assert o in [&#39;&#39;,&#39;verbatim&#39;],&#34;Invalid option: &#34;+o
            return &#39;&#39;

        self.process(text, runner=scanner, record_substitutions=True)
        print(f&#39;Found {self.lc!s} lines of Python.&#39;)
        saveddeps = self.deps
        self.deps = {}
        for k in cache[&#39;deps&#39;]:
            self.dep(k)
        self.resolvedeps()
        cached = True
        if cache[&#39;disable_cache&#39;]:
            print(&#39;disable_cache=True&#39;)
            cached = False
        elif cache[&#39;argv&#39;] != self.argv:
            print(&#39;argv differs&#39;, self.argv, cache[&#39;argv&#39;])
            cached = False
        elif cache[&#39;fragments&#39;] != self.fragments:
            F1 = dict(enumerate(cache[&#39;fragments&#39;]))
            F2 = dict(enumerate(self.fragments))
            k = dictdiff(F1, F2)[0]
            print(&#39;Fragment #&#39;, k,
                  &#39;\nCached version:\n&#39;, F1[k] if k in F1 else None,
                  &#39;\nLive version:\n&#39;, F2[k] if k in F2 else None)
            cached = False
        elif self.deps != cache[&#39;deps&#39;]:
            F1 = cache[&#39;deps&#39;]
            F2 = self.deps
            k = dictdiff(F1, F2)[0]
            print(&#39;Dependency mismatch&#39;, k,
                  &#39;\nCached version:\n&#39;, F1[k] if k in F1 else None,
                  &#39;\nLive version:\n&#39;, F2[k] if k in F2 else None)
            cached = False
        if cached:
            print(&#39;Using cached Python outputs&#39;)
            for k, v in cache.items():
                self.__dict__[k] = v
            self.subcount = -1

            def subber(C, k, o):
                self.subcount += 1
                if(o==&#39;&#39;):
                    return self.outputs[self.subcount]
                if(o==&#39;verbatim&#39;):
                    return C

            self.compiled = self.process(text, runner=subber, record_substitutions=False)
        else:
            print(&#39;Cache is invalidated.&#39;)
            self.deps = saveddeps
            self.outputs = []

            def appender(C, k, o):
                result = self.run(C, k)
                self.outputs.append(&#39;&#39;.join(map(self.mylatex, result)))
                if(o==&#39;&#39;):
                    return self.outputs[-1]
                if(o==&#39;verbatim&#39;):
                    return C

            self.compiled = self.process(text, runner=appender, record_substitutions=False)
        sys.stdout.flush()
        if self.pyptexfilename:
            print(f&#39;Saving to file: {self.pyptexfilename}&#39;)
            with open(self.pyptexfilename, &#39;wt&#39;) as file:
                file.write(self.compiled)
        self.resolvedeps()
        print(f&#39;Dependencies are:\n{self.deps!s}&#39;)
        numlines = len(text.split(&#39;\n&#39;))
        linemaps = []
        prevline = 0
        for k in range(len(self.outputs)):
            linemaps.append(list(range(prevline+1,self.__substarts__[k]+1)))
            count = len(self.outputs[k].split(&#39;\n&#39;))
            linemaps.append([self.__substarts__[k]]*(count-1))
            prevline = self.__subends__[k]
        linemaps.append(list(range(prevline+1,numlines+1)))
        self.linemap = [str(x) for sublist in linemaps for x in sublist]
        print(&#39;Saving cache file&#39;, self.cachefilename)
        with open(self.cachefilename, &#39;wb&#39;) as file:
            cache = {}
            for k, v in self.__dict__.items():
                if k[0:2] == &#39;__&#39; and k[-2:] == &#39;__&#39;:
                    pass
                elif callable(v):
                    pass
                else:
                    cache[k] = v
            pickle.dump(cache, file)
        if self.latexcommand:
            cmd = self.latexcommand.format(**self.__dict__)
            print(f&#39;Running Latex command:\n{cmd}&#39;)
            self.exitcode = os.system(cmd)

    def bib(self, bib=&#34;&#34;):
        &#34;&#34;&#34;A helper function for creating a `.bib` file. If `pyp=pyptex(&#39;a.tex&#39;)`,
        then `pyp.bib(&#39;&#39;&#39;@book{knuth1984texbook, title={The {TEXbook}},
        author={Knuth, Donald Ervin and Bibby, Duane}}&#39;&#39;&#39;)` creates a file
        `a.bib` with the given text. This is just a convenience function
        that makes it easier to incorporate the bibtex file straight into the
        `a.tex` source. In `a.tex`, the typical way of using it is:
        `\\bibliography{@{{{pyp.bib(&#34;...&#34;)}}}}`.
        &#34;&#34;&#34;
        self.bibs.append(bib)
        with self.open(self.bibfilename, &#39;wt&#39;) as file:
            file.write(&#34;\n&#34;.join(self.bibs))
        return self.filename

    def dep(self, filename):
        &#34;&#34;&#34;If `pyp=pyptex(&#39;a.tex&#39;)`, then `pyp.dep(filename)` declares that the Python code
        in `a.tex` depends on the file designated by `filename`. When the object
        `pyptex(&#39;a.tex&#39;)` is constructed, the file `a.pickle` will be loaded (if it exists).
        `a.pickle` is a cache of the results of the Python calculations in `a.tex`.
        If the cache is deemed valid, the `pyptex` constructor does not rerun all
        the Python fragments in `a.tex` but instead uses the previously cached outputs.

        The cache is invalidated under the following scenarios:
        1. The new Python fragments in `a.tex` are not identical to the cached fragments.
        2. The &#34;last modification&#34; timestamp on dependencies is not the same as in the cache.
        3. `pyp.disable_cache==True`.

        The list of dependencies defaults to only the `pyptex` executable. Additional
        dependencies can be manually declared via `pyp.dep(filename)`.

        For convenience, `pyp.dep(filename)` returns filename.
        &#34;&#34;&#34;
        self.deps[filename] = &#39;&#39;
        return filename

    def resolvedeps(self):
        &#34;&#34;&#34;An internal function that actually computes the datestamps of dependencies.&#34;&#34;&#34;
        for k in self.deps:
            try:
                ds = format_my_nanos(os.stat(k).st_mtime_ns)
            except Exception:
                ds = &#39;&#39;
            self.deps[k] = ds

    def input(self, filename, argv=False):
        r&#34;&#34;&#34;If `pyp = pyptex(&#39;a.tex&#39;)` then
        `pyp.input(&#39;b.tex&#39;)`
        returns the string `\input{&#34;b.pyptex&#34;}`. The common way of using this is to
        put `@{pyp.input(&#39;b.tex&#39;)}` somewhere in `a.tex`.
        The function `pyp.input(&#39;b.tex&#39;)` internally calls the constructor
        `pyptex(&#39;b.tex&#39;)` so that `b.pyptex` is compiled from `b.tex`.

        Note that the two files `a.tex` and `b.tex` are &#34;semantically isolated&#34;. All
        calculations, variables and functions defined in `a.tex` live in a global scope
        that is private to `a.tex`, much like each Python module has a private global
        scope. In a similar fashion, `b.tex` has its own private global scope.
        The global `pyp` objects in `a.tex` and `b.tex` are also different instances
        of the `pyptex` class. This is similar to the notion of &#34;compilation units&#34; in
        the C programming language.

        From `a.tex`, one can retrieve global variables of `b.tex` as follows. If
        `foo = pyp.input(&#39;b.tex&#39;)`, and if `b.tex` defines a global variable `x`,
        then it can be retrieved by `foo.x`. The `foo` variable is an instance of a
        `pyptexNameSpace` that contains the global scope of `b.tex`. This type has a
        custom string representation, so that `str(foo)` or `@{foo}` is
        `&#39;\input{b.pyptex}&#39;`.

        If one wishes to pass some parameters from `a.tex` to `b.tex`, one may use
        the notation `pyp.input(&#39;b.tex&#39;, argv)`, which will initialize the global
        `pyp` object of `b.tex` so that it contains the field `pyp.argv=argv`.
        &#34;&#34;&#34;
        ret = pyptex(filename, argv or self.argv, False)
        ret2 = pyptexNameSpace(ret.__globals__)
        return ret2

    def open(self, filename, *argv, **kwargs):
        &#34;&#34;&#34;If pyp = pyptex(&#39;a.tex&#39;) then pyp.open(filename, ...) is a wrapper for
        the builtin function open(filename, ...) that further adds filename to
        the list of dependencies via pyp.dep(filename).
        &#34;&#34;&#34;
        self.dep(filename)
        return open(filename, *argv, **kwargs)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pyptex.pyptex.bib"><code class="name flex">
<span>def <span class="ident">bib</span></span>(<span>self, bib='')</span>
</code></dt>
<dd>
<div class="desc"><p>A helper function for creating a <code>.bib</code> file. If <code>pyp=pyptex('a.tex')</code>,
then <code>pyp.bib('''@book{knuth1984texbook, title={The {TEXbook}},
author={Knuth, Donald Ervin and Bibby, Duane}}''')</code> creates a file
<code>a.bib</code> with the given text. This is just a convenience function
that makes it easier to incorporate the bibtex file straight into the
<code>a.tex</code> source. In <code>a.tex</code>, the typical way of using it is:
<code>\bibliography{@{{{pyp.bib("...")}}}}</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bib(self, bib=&#34;&#34;):
    &#34;&#34;&#34;A helper function for creating a `.bib` file. If `pyp=pyptex(&#39;a.tex&#39;)`,
    then `pyp.bib(&#39;&#39;&#39;@book{knuth1984texbook, title={The {TEXbook}},
    author={Knuth, Donald Ervin and Bibby, Duane}}&#39;&#39;&#39;)` creates a file
    `a.bib` with the given text. This is just a convenience function
    that makes it easier to incorporate the bibtex file straight into the
    `a.tex` source. In `a.tex`, the typical way of using it is:
    `\\bibliography{@{{{pyp.bib(&#34;...&#34;)}}}}`.
    &#34;&#34;&#34;
    self.bibs.append(bib)
    with self.open(self.bibfilename, &#39;wt&#39;) as file:
        file.write(&#34;\n&#34;.join(self.bibs))
    return self.filename</code></pre>
</details>
</dd>
<dt id="pyptex.pyptex.cite"><code class="name flex">
<span>def <span class="ident">cite</span></span>(<span>self, b)</span>
</code></dt>
<dd>
<div class="desc"><p>If <code>pyp</code> is an object of type <code><a title="pyptex.pyptex" href="#pyptex.pyptex">pyptex</a></code>, then <code>pyp.cite(X)</code> adds the relevant
entry to the bibTeX file and returns the entry name. Example usage:</p>
<p><code>\cite{@{{{pyp.cite(r"@article{seb97,title=Some title etc...}")}}}}</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cite(self,b):
    r&#34;&#34;&#34;If `pyp` is an object of type `pyptex`, then `pyp.cite(X)` adds the relevant
    entry to the bibTeX file and returns the entry name. Example usage:

    `\cite{@{{{pyp.cite(r&#34;@article{seb97,title=Some title etc...}&#34;)}}}}`
    &#34;&#34;&#34;
    self.bibs.append(b)
    return bibentryname.match(b).group(1).strip()</code></pre>
</details>
</dd>
<dt id="pyptex.pyptex.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Clears all global variable.</p>
<p>pyptex.clear() clears all the global variables of the caller. Example usage:</p>
<pre><code class="language-python">a = 1
print(a)      # this prints 1
pyp.clear()
print(a)      # this raises an exception because
              # a is now undefined.
</code></pre>
<p>The global scope is restored from the dictionary <code>pyp.__frozen__</code>, which initially only contains
the pyp object and the <code>__builtins__</code> module. One can add more items to the <code>__frozen__</code> dict, e.g.
by importing some standard module. For example,</p>
<pre><code class="language-python">my_variable = 78
import sys
pyp.freeze()     # This freezes my_variable and sys.
foo = 1          # Now foo is defined...
pyp.clear()
# ...Now foo is undefined, but my_variable is still 78,
# and the sys module is still available.
</code></pre>
<p>Note that <code>pyp.freeze()</code> performs a shallow copy, so:</p>
<pre><code class="language-python">a = [1,2,3]
pyp.freeze()  # a = [1,2,3] is now in the frozen scope.
a[1] = 7      # Now a = [1,7,3] in the global scope.
pyp.clear()
# Still a = [1,7,3] because the scope copy was shallow.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self):
    &#34;&#34;&#34;Clears all global variable.

    pyptex.clear() clears all the global variables of the caller. Example usage:
    ```python
    a = 1
    print(a)      # this prints 1
    pyp.clear()
    print(a)      # this raises an exception because
                  # a is now undefined.
    ```
    
    The global scope is restored from the dictionary `pyp.__frozen__`, which initially only contains
    the pyp object and the `__builtins__` module. One can add more items to the `__frozen__` dict, e.g.
    by importing some standard module. For example,

    ```python
    my_variable = 78
    import sys
    pyp.freeze()     # This freezes my_variable and sys.
    foo = 1          # Now foo is defined...
    pyp.clear()
    # ...Now foo is undefined, but my_variable is still 78,
    # and the sys module is still available.
    ```

    Note that `pyp.freeze()` performs a shallow copy, so:
    ```python
    a = [1,2,3]
    pyp.freeze()  # a = [1,2,3] is now in the frozen scope.
    a[1] = 7      # Now a = [1,7,3] in the global scope.
    pyp.clear()
    # Still a = [1,7,3] because the scope copy was shallow.
    ```
    &#34;&#34;&#34;
    foo = self.__frozen__
    bar = inspect.stack()[1][0].f_globals
    for k,v in foo.items():
        bar[k] = v
    kk = list(bar.keys())
    for k in kk:
        if k not in foo:
            del bar[k]</code></pre>
</details>
</dd>
<dt id="pyptex.pyptex.dep"><code class="name flex">
<span>def <span class="ident">dep</span></span>(<span>self, filename)</span>
</code></dt>
<dd>
<div class="desc"><p>If <code>pyp=pyptex('a.tex')</code>, then <code>pyp.dep(filename)</code> declares that the Python code
in <code>a.tex</code> depends on the file designated by <code>filename</code>. When the object
<code>pyptex('a.tex')</code> is constructed, the file <code>a.pickle</code> will be loaded (if it exists).
<code>a.pickle</code> is a cache of the results of the Python calculations in <code>a.tex</code>.
If the cache is deemed valid, the <code><a title="pyptex.pyptex" href="#pyptex.pyptex">pyptex</a></code> constructor does not rerun all
the Python fragments in <code>a.tex</code> but instead uses the previously cached outputs.</p>
<p>The cache is invalidated under the following scenarios:
1. The new Python fragments in <code>a.tex</code> are not identical to the cached fragments.
2. The "last modification" timestamp on dependencies is not the same as in the cache.
3. <code>pyp.disable_cache==True</code>.</p>
<p>The list of dependencies defaults to only the <code><a title="pyptex.pyptex" href="#pyptex.pyptex">pyptex</a></code> executable. Additional
dependencies can be manually declared via <code>pyp.dep(filename)</code>.</p>
<p>For convenience, <code>pyp.dep(filename)</code> returns filename.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dep(self, filename):
    &#34;&#34;&#34;If `pyp=pyptex(&#39;a.tex&#39;)`, then `pyp.dep(filename)` declares that the Python code
    in `a.tex` depends on the file designated by `filename`. When the object
    `pyptex(&#39;a.tex&#39;)` is constructed, the file `a.pickle` will be loaded (if it exists).
    `a.pickle` is a cache of the results of the Python calculations in `a.tex`.
    If the cache is deemed valid, the `pyptex` constructor does not rerun all
    the Python fragments in `a.tex` but instead uses the previously cached outputs.

    The cache is invalidated under the following scenarios:
    1. The new Python fragments in `a.tex` are not identical to the cached fragments.
    2. The &#34;last modification&#34; timestamp on dependencies is not the same as in the cache.
    3. `pyp.disable_cache==True`.

    The list of dependencies defaults to only the `pyptex` executable. Additional
    dependencies can be manually declared via `pyp.dep(filename)`.

    For convenience, `pyp.dep(filename)` returns filename.
    &#34;&#34;&#34;
    self.deps[filename] = &#39;&#39;
    return filename</code></pre>
</details>
</dd>
<dt id="pyptex.pyptex.freeze"><code class="name flex">
<span>def <span class="ident">freeze</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>'Freezes' the global scope of the caller by performing a shallow copy and copying it to
<code>pyp.__frozen__</code></p>
<p>See also <code><a title="pyptex.pyptex.clear" href="#pyptex.pyptex.clear">pyptex.clear()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def freeze(self):
    &#34;&#34;&#34;&#39;Freezes&#39; the global scope of the caller by performing a shallow copy and copying it to 
    `pyp.__frozen__`

    See also `pyptex.clear()`&#34;&#34;&#34;
    self.__frozen__ = inspect.stack()[1][0].f_globals.copy()</code></pre>
</details>
</dd>
<dt id="pyptex.pyptex.genname"><code class="name flex">
<span>def <span class="ident">genname</span></span>(<span>self, pattern: str = 'fig{gencount}.eps')</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a filename</p>
<p>To produce an automatically generated filename, use the statement
<code>pyp.genname()</code>, where <code>pyp</code> is an object of type <code><a title="pyptex.pyptex" href="#pyptex.pyptex">pyptex</a></code>, for parsing a
given file <code>a.tex</code>. By default, this will generate the name
<code>'a-generated/fig{gencount}.eps'</code>.
The subdirectory can be overridden by overwriting <code>pyp.gendir</code>,
and <code>gencount</code> denotes <code>pyp.gencount</code>. Any desired pattern can be used,
for example:
<code>name = pyp.genname('hello-{gencount}-{thing}.txt')</code>
will return something like <code>'a-generated/hello-X-Y.txt'</code>, where
<code>X</code> is <code>pyp.gencount</code> and <code>Y</code> is <code>pyp.thing</code>.</p>
<p><code>pyp.genname()</code> does not actually create the file. <code>pyp.genname()</code> increments
<code>pyp.gencount</code> every time it is called.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def genname(self, pattern: str = &#39;fig{gencount}.eps&#39;):
    r&#34;&#34;&#34;Generate a filename

    To produce an automatically generated filename, use the statement
    `pyp.genname()`, where `pyp` is an object of type `pyptex`, for parsing a
    given file `a.tex`. By default, this will generate the name
    `&#39;a-generated/fig{gencount}.eps&#39;`.
    The subdirectory can be overridden by overwriting `pyp.gendir`,
    and `gencount` denotes `pyp.gencount`. Any desired pattern can be used,
    for example:
        `name = pyp.genname(&#39;hello-{gencount}-{thing}.txt&#39;)`
    will return something like `&#39;a-generated/hello-X-Y.txt&#39;`, where
    `X` is `pyp.gencount` and `Y` is `pyp.thing`.

    `pyp.genname()` does not actually create the file. `pyp.genname()` increments
    `pyp.gencount` every time it is called.
    &#34;&#34;&#34;
    self.gencount += 1
    return f&#39;{self.gendir}/{pattern.format(**self.__dict__)}&#39;</code></pre>
</details>
</dd>
<dt id="pyptex.pyptex.input"><code class="name flex">
<span>def <span class="ident">input</span></span>(<span>self, filename, argv=False)</span>
</code></dt>
<dd>
<div class="desc"><p>If <code>pyp = pyptex('a.tex')</code> then
<code>pyp.input('b.tex')</code>
returns the string <code>\input{"b.pyptex"}</code>. The common way of using this is to
put <code>@{pyp.input('b.tex')}</code> somewhere in <code>a.tex</code>.
The function <code>pyp.input('b.tex')</code> internally calls the constructor
<code>pyptex('b.tex')</code> so that <code>b.pyptex</code> is compiled from <code>b.tex</code>.</p>
<p>Note that the two files <code>a.tex</code> and <code>b.tex</code> are "semantically isolated". All
calculations, variables and functions defined in <code>a.tex</code> live in a global scope
that is private to <code>a.tex</code>, much like each Python module has a private global
scope. In a similar fashion, <code>b.tex</code> has its own private global scope.
The global <code>pyp</code> objects in <code>a.tex</code> and <code>b.tex</code> are also different instances
of the <code><a title="pyptex.pyptex" href="#pyptex.pyptex">pyptex</a></code> class. This is similar to the notion of "compilation units" in
the C programming language.</p>
<p>From <code>a.tex</code>, one can retrieve global variables of <code>b.tex</code> as follows. If
<code>foo = pyp.input('b.tex')</code>, and if <code>b.tex</code> defines a global variable <code>x</code>,
then it can be retrieved by <code>foo.x</code>. The <code>foo</code> variable is an instance of a
<code>pyptexNameSpace</code> that contains the global scope of <code>b.tex</code>. This type has a
custom string representation, so that <code>str(foo)</code> or <code>@{foo}</code> is
<code>'\input{b.pyptex}'</code>.</p>
<p>If one wishes to pass some parameters from <code>a.tex</code> to <code>b.tex</code>, one may use
the notation <code>pyp.input('b.tex', argv)</code>, which will initialize the global
<code>pyp</code> object of <code>b.tex</code> so that it contains the field <code>pyp.argv=argv</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def input(self, filename, argv=False):
    r&#34;&#34;&#34;If `pyp = pyptex(&#39;a.tex&#39;)` then
    `pyp.input(&#39;b.tex&#39;)`
    returns the string `\input{&#34;b.pyptex&#34;}`. The common way of using this is to
    put `@{pyp.input(&#39;b.tex&#39;)}` somewhere in `a.tex`.
    The function `pyp.input(&#39;b.tex&#39;)` internally calls the constructor
    `pyptex(&#39;b.tex&#39;)` so that `b.pyptex` is compiled from `b.tex`.

    Note that the two files `a.tex` and `b.tex` are &#34;semantically isolated&#34;. All
    calculations, variables and functions defined in `a.tex` live in a global scope
    that is private to `a.tex`, much like each Python module has a private global
    scope. In a similar fashion, `b.tex` has its own private global scope.
    The global `pyp` objects in `a.tex` and `b.tex` are also different instances
    of the `pyptex` class. This is similar to the notion of &#34;compilation units&#34; in
    the C programming language.

    From `a.tex`, one can retrieve global variables of `b.tex` as follows. If
    `foo = pyp.input(&#39;b.tex&#39;)`, and if `b.tex` defines a global variable `x`,
    then it can be retrieved by `foo.x`. The `foo` variable is an instance of a
    `pyptexNameSpace` that contains the global scope of `b.tex`. This type has a
    custom string representation, so that `str(foo)` or `@{foo}` is
    `&#39;\input{b.pyptex}&#39;`.

    If one wishes to pass some parameters from `a.tex` to `b.tex`, one may use
    the notation `pyp.input(&#39;b.tex&#39;, argv)`, which will initialize the global
    `pyp` object of `b.tex` so that it contains the field `pyp.argv=argv`.
    &#34;&#34;&#34;
    ret = pyptex(filename, argv or self.argv, False)
    ret2 = pyptexNameSpace(ret.__globals__)
    return ret2</code></pre>
</details>
</dd>
<dt id="pyptex.pyptex.mylatex"><code class="name flex">
<span>def <span class="ident">mylatex</span></span>(<span>self, X)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mylatex(self, X):
    if X is None:
        return &#39;&#39;
    if isinstance(X, str):
        return X
    if isinstance(X,pyptexNameSpace):
        return str(X)
    if isinstance(X,matplotlib.pyplot.Figure):
        self.__setupfig__(X)
        print(X.__IG__)
        X.canvas.print_figure(X.__FIGNAME__)
        X.drawn = True
        return X.__IG__
    if isinstance(X,self.__sympy_plot__):
        return &#34;&#34;
    if isinstance(X,matplotlib.artist.Artist):
        return &#34;&#34;
    if isinstance(X,list) and isinstance(X[0],matplotlib.artist.Artist):
        return &#34;&#34;
    return sympy.latex(X)</code></pre>
</details>
</dd>
<dt id="pyptex.pyptex.open"><code class="name flex">
<span>def <span class="ident">open</span></span>(<span>self, filename, *argv, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>If pyp = pyptex('a.tex') then pyp.open(filename, &hellip;) is a wrapper for
the builtin function open(filename, &hellip;) that further adds filename to
the list of dependencies via pyp.dep(filename).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open(self, filename, *argv, **kwargs):
    &#34;&#34;&#34;If pyp = pyptex(&#39;a.tex&#39;) then pyp.open(filename, ...) is a wrapper for
    the builtin function open(filename, ...) that further adds filename to
    the list of dependencies via pyp.dep(filename).
    &#34;&#34;&#34;
    self.dep(filename)
    return open(filename, *argv, **kwargs)</code></pre>
</details>
</dd>
<dt id="pyptex.pyptex.pp"><code class="name flex">
<span>def <span class="ident">pp</span></span>(<span>self, Z)</span>
</code></dt>
<dd>
<div class="desc"><p>Pretty-prints the template text string <code>Z</code>, using substitutions from the local
scope that is <code>levels</code> calls up on the stack. The template character is @.</p>
<p>For example, assume the caller has the value <code>x=3</code> in its local variables. Then,
<code>pyp.pp("$x=@x$")</code> produces <code>$x=3$</code>.</p>
<p><code>pp</code> can also evaluate Python expressions in the template string, e.g.
<code>pyp.pp("@{3+4}")</code> produces <code>7</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pp(self, Z):
    r&#34;&#34;&#34;Pretty-prints the template text string `Z`, using substitutions from the local
    scope that is `levels` calls up on the stack. The template character is @.

    For example, assume the caller has the value `x=3` in its local variables. Then,
    `pyp.pp(&#34;$x=@x$&#34;)` produces `$x=3$`.

    `pp` can also evaluate Python expressions in the template string, e.g.
    `pyp.pp(&#34;@{3+4}&#34;)` produces `7`.
    &#34;&#34;&#34;
    global ppparser,__stringtag__
    foo = inspect.currentframe().f_back
    def do_work(m):
        if m.start(1) &gt;= 0:
            return &#39;@&#39;
        for k in [2,3]:
            if m.start(k) &gt;= 0:
                return self.mylatex(eval(compile(m.group(k),__stringtag__,mode=&#39;eval&#39;),
                    foo.f_globals, foo.f_locals))
        raise Exception(&#34;Tragic regular expression committed seppuku&#34;)

    return ppparser.sub(do_work, Z)</code></pre>
</details>
</dd>
<dt id="pyptex.pyptex.print"><code class="name flex">
<span>def <span class="ident">print</span></span>(<span>self, *argv)</span>
</code></dt>
<dd>
<div class="desc"><p>If <code>pyp</code> is an object of type <code><a title="pyptex.pyptex" href="#pyptex.pyptex">pyptex</a></code>, <code>pyp.print(X)</code> causes <code>X</code> to be converted
to its latex representation and substituted into the <code>a.pyptex</code> output file.
The conversion is given by <code>sympy.latex(X)</code>, except that <code>None</code> is converted
to the empty string.</p>
<p>Many values can be printed at once with the notation <code>pyp.print(X, Y, &hellip;)</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print(self, *argv):
    &#34;&#34;&#34;If `pyp` is an object of type `pyptex`, `pyp.print(X)` causes `X` to be converted
    to its latex representation and substituted into the `a.pyptex` output file.
    The conversion is given by `sympy.latex(X)`, except that `None` is converted
    to the empty string.

    Many values can be printed at once with the notation `pyp.print(X, Y, ...)`.&#34;&#34;&#34;
    for k in range(len(argv)):
        if isinstance(argv[k],matplotlib.pyplot.Figure):
            self.mylatex(argv[k])
    self.__accum__.extend(argv)</code></pre>
</details>
</dd>
<dt id="pyptex.pyptex.showall"><code class="name flex">
<span>def <span class="ident">showall</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def showall(self):
    for num, figmanager in enumerate(Gcf.get_all_fig_managers()):
        fig = figmanager.canvas.figure
        self.__setupfig__(fig)
        if fig.drawn:
            pass
        else:
            self.print(fig)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#pyptex-the-python-preprocessor-for-tex">PypTeX: the Python Preprocessor for TeX</a><ul>
<li><a href="#author-sebastien-loisel">Author: Sébastien Loisel</a></li>
</ul>
</li>
<li><a href="#installation">Installation</a></li>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#slightly-bigger-examples">Slightly bigger examples</a></li>
<li><a href="#plotting-with-sympy-and-matplotlib">Plotting with sympy and matplotlib</a></li>
<li><a href="#template-preprocessing-vs-embedding">Template preprocessing vs embedding</a></li>
<li><a href="#pretty-printing-template-strings-from-python-with-pp">Pretty-printing template strings from Python with pp</a></li>
<li><a href="#caching">Caching</a></li>
<li><a href="#scopes">Scopes</a></li>
<li><a href="#texshop">TeXShop</a></li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pyptex.pyptexmain" href="#pyptex.pyptexmain">pyptexmain</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyptex.MyWriter" href="#pyptex.MyWriter">MyWriter</a></code></h4>
<ul class="">
<li><code><a title="pyptex.MyWriter.write_from" href="#pyptex.MyWriter.write_from">write_from</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyptex.pyptex" href="#pyptex.pyptex">pyptex</a></code></h4>
<ul class="two-column">
<li><code><a title="pyptex.pyptex.bib" href="#pyptex.pyptex.bib">bib</a></code></li>
<li><code><a title="pyptex.pyptex.cite" href="#pyptex.pyptex.cite">cite</a></code></li>
<li><code><a title="pyptex.pyptex.clear" href="#pyptex.pyptex.clear">clear</a></code></li>
<li><code><a title="pyptex.pyptex.dep" href="#pyptex.pyptex.dep">dep</a></code></li>
<li><code><a title="pyptex.pyptex.freeze" href="#pyptex.pyptex.freeze">freeze</a></code></li>
<li><code><a title="pyptex.pyptex.genname" href="#pyptex.pyptex.genname">genname</a></code></li>
<li><code><a title="pyptex.pyptex.input" href="#pyptex.pyptex.input">input</a></code></li>
<li><code><a title="pyptex.pyptex.mylatex" href="#pyptex.pyptex.mylatex">mylatex</a></code></li>
<li><code><a title="pyptex.pyptex.open" href="#pyptex.pyptex.open">open</a></code></li>
<li><code><a title="pyptex.pyptex.pp" href="#pyptex.pyptex.pp">pp</a></code></li>
<li><code><a title="pyptex.pyptex.print" href="#pyptex.pyptex.print">print</a></code></li>
<li><code><a title="pyptex.pyptex.showall" href="#pyptex.pyptex.showall">showall</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>